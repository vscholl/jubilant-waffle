---
title: "explore_pplot_data"
author: "Victoria Scholl"
date: "3/12/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE,
                      message = FALSE)
library(plyr)
library(dplyr)
library(sf)
library(ggplot2)
library(stringr) # for creating ribbon plot
library(stats)

# set working directory
setwd("~/github/jubilant-waffle/code/")

# load any local functions in external files 
source("supporting_functions.R")

# code for NEON site 
site_code <- 'NIWO'

# define the "bad bands" wavelength ranges in nanometers, where atmospheric 
# absorption creates unreliable reflectance values. 
bad_band_window_1 <- c(1340, 1445)
bad_band_window_2 <- c(1790, 1955)

#specify output directory 
out_dir <- paste0('../output/', site_code, '/')

# list of taxon IDs present at the NEON NIWO site
taxonList <- c("ABLAL","PICOL","PIEN","PIFL2")
```

# Exploring MRS-04 Data

## Permanent Plot measurements

```{r mrs4_pp_data}
# read the Excel file with MRS-04 Permanent Plot measurements
# I saved a .csv with the MRS4 sheet
mrs4_filename <- "../data/NIWO/tom_mrs04/Veblen_LTER_PP_Data_03262018_MRS04.csv"
mrs4_data <- read.csv(mrs4_filename)

# filter the data for entries with hc3 == 1
# hc3 column: Height class estimated during re-measurement in 2016.  
# 1 = main canopy, 2 = intermediate, 3 = subcanopy
mrs4_data_mainCanopy <- mrs4_data %>% dplyr::filter(hc3==1) %>% 
                          # convert from list to data frame 
                          as.data.frame() %>% 
                            # rename the Sp. and Tree. columns
                            dplyr::rename(taxonID = Sp.,
                                          TreeNum = Tree.)

# These taxon ID codes are different from the NEON taxon ID codes -
# these will be adjusted later. 

# count the number of trees per taxon ID in the main canopy
plyr::count(mrs4_data_mainCanopy, 'taxonID') %>%
  knitr::kable() %>%
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover",
                                                  "condensed"),
                            full_width = F,
                            position = "left")
```

## Georeferenced tree point locations 

```{r}
# directory containing georeferenced shapefiles at MRS4
input_dir <- "../data/NIWO/tom_mrs04/mrs04_georeferenced_using_unavco_gps_points/"

# the "MRS4point.shp" feature class contains point locations
# for each numbered tree (TreeNum attribute)
mrs4point_layer <- "MRS4point.shp"
mrs4point <- sf::st_read(paste0(input_dir, mrs4point_layer))

# print the number of trees with stem locations in the MRS4point.shp file
print(paste0("There are ", as.character(length(mrs4point$TreeNum)), 
             " trees in the MRS4point shapefile"))

# plot all tree stem points
ggplot2::ggplot() + 
  ggplot2::geom_sf(data = mrs4point, size = 1, color = "black") + 
  ggtitle("All stem points within MRS4point.shp") + 
  coord_sf()

# The other shapefiles in the input_dir contain sapling measurements. 
# I will focus on the larger trees for now. 
```



```{r filter_treeNum_mrs4point}
# filter the tree point shapefiles for entries with matching tree numbers
# to the main canopy data (h3 == 1 from earlier)
mrs4point_mainCanopy <- mrs4point %>% 
              dplyr::filter(TreeNum %in% mrs4_data_mainCanopy$TreeNum)

# print the number of trees with stem locations and Main Canopy height class
print(paste0("There are ", as.character(length(mrs4point_mainCanopy$TreeNum)), 
             " trees in the MRS4point shapefile designated as the Main Canopy height class"))

ggplot2::ggplot() + 
  ggplot2::geom_sf(data = mrs4point_mainCanopy, size = 1, color = "black") + 
  ggtitle("MRS4point.shp filtered for Main Canopy Tree Numbers") + 
  coord_sf()

```

```{r newMRSpoint, eval=FALSE, include=FALSE}

# when the "newMRS4point.shp" file is used and checked,
# there are no trees that have the Main Canopy height class! 
# so I won't be using this shapefile for now. 

# the "newMRS4point.shp" feature class contains point locations
# for each numbered tree (TreeNum attribute)
mrs4point_layer <- "newMRS4point.shp"


mrs4point <- sf::st_read(paste0(input_dir, mrs4point_layer))

# print the number of trees with stem locations in the MRS4point.shp file
print(paste0("There are ", as.character(length(mrs4point$TreeNum)), 
             " trees in the MRS4point shapefile"))

# plot the tree points
ggplot2::ggplot() + 
  ggplot2::geom_sf(data = mrs4point, size = 1, color = "black") + 
  ggtitle("MRS4point.shp") + 
  coord_sf()

# filter the tree point shapefiles for entries with matching tree numbers
# to the main canopy data (h3 == 1 from earlier)
mrs4point_mainCanopy <- mrs4point %>% 
              dplyr::filter(TreeNum %in% mrs4_data_mainCanopy$TreeNum)

# print the number of trees with stem locations and Main Canopy height class
print(paste0("There are ", as.character(length(mrs4point_mainCanopy$TreeNum)), 
             " trees in the MRS4point shapefile designated as the Main Canopy height class"))

```


Now that we know which Tree Numbers are designated as the Main Canopy height class and also have stem locations in the shapefile, let's add a taxonID attribute to each point in the shapefile to keep track of its species. 

```{r taxonID_cleaning}
# create a look-up table (LUT) where the first column
# contains the taxonID codes and second column contains correspnding Tree Number.
taxonID_TreeNum_lut <- data.frame(taxonID = mrs4_data_mainCanopy$taxonID, 
                                  TreeNum = as.numeric(mrs4_data_mainCanopy$TreeNum))

# get the indices where the Tree Numbers in the point shapefile 
# match with Tree Numbers in the tree data 
idx <- match(mrs4point_mainCanopy$TreeNum, taxonID_TreeNum_lut$TreeNum)
mrs4point_mainCanopy$taxonID <- taxonID_TreeNum_lut[idx, "taxonID"]

# the species codes are different from the taxonID list used by NEON.
# let's adjust them to be the same. PIEN entries already match.  
# first, remove the factors so the taxonID values can be modified as characters.
mrs4point_mainCanopy$taxonID <- as.character(mrs4point_mainCanopy$taxonID)
mrs4point_mainCanopy$taxonID[mrs4point_mainCanopy$taxonID=="ABLA"] <- "ABLAL"
mrs4point_mainCanopy$taxonID[mrs4point_mainCanopy$taxonID=="PICO"] <- "PICOL"
mrs4point_mainCanopy$taxonID[mrs4point_mainCanopy$taxonID=="PIFL"] <- "PIFL2"

# filter the entries to species in the taxonID list 
# (remove the UNKN species entries)
mrs4point_mainCanopy <- mrs4point_mainCanopy %>% dplyr::filter(taxonID %in% taxonList)

# take another look at the number of trees per taxonID 
plyr::count(mrs4point_mainCanopy, 'taxonID') %>%
  knitr::kable() %>%
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover",
                                                  "condensed"),
                            full_width = F,
                            position = "left")
```

Plot the stem points at MRS-04 designated as the Main Canopy height class and color them based on their species (taxon ID). 
```{r}
ggplot2::ggplot() + 
  ggplot2::geom_sf(data = mrs4point_mainCanopy, 
                   aes(colour=taxonID),
                   size = 1) + 
  ggtitle("MRS-04 Main Canopy stem points colored by species") + 
  coord_sf() +
  scale_color_brewer(palette = "Spectral")
```

```{r plot_stems_on_rgb}

# read RGB tile that contains the MRS-04 plot
rgb_filename <- "../data/NIWO/rgb/2017_NIWO_1_452000_4432000_image.tif"

rgb_red <- raster::raster(rgb_filename, band = 1) 
rgb_green <- raster::raster(rgb_filename, band = 2) 
rgb_blue <- raster::raster(rgb_filename, band = 3) 
rgb_stack <- raster::stack(rgb_red,rgb_green, rgb_blue)
rgb_cropped <- raster::crop(rgb_stack, as(mrs4point_mainCanopy, 'Spatial'))
raster::plotRGB(rgb_cropped, r = 1, g = 2, b = 3)
points(as(mrs4point_mainCanopy, 'Spatial'), pch = 16, cex = 0.5)
```


# Random Forest Classification

In theory, we know the species at each of the point locations in the plot above.
The code below extracts features from the remote sensing data cube and run the random forest classifier to predict species, then compare to the known species. 

## Extract features

For each stem location, extract features from the AOP remote sensing data cube. 

```{r extract_features}
# read stacked AOP data
stacked_aop_filename <- "../data/NIWO/stacked_aop_data/stacked_aop_data_452000_4432000.rds"
stacked_aop_data <- readRDS(file = stacked_aop_filename)

# add columns for the X,Y location of each tree 
shp_coords <- mrs4point_mainCanopy %>% 
      sf::st_coordinates() %>% 
      as.data.frame()

# add new columns for the tree location coordinates 
mrs4point_mainCanopy$X <- shp_coords$X
mrs4point_mainCanopy$Y <- shp_coords$Y

# filter shapefile for only the trees within the current tile
trees_in <- mrs4point_mainCanopy %>% 
      dplyr::filter(X >= stacked_aop_data@extent[1] & 
                    X < stacked_aop_data@extent[2] & 
                    Y >= stacked_aop_data@extent[3] & 
                    Y  < stacked_aop_data@extent[4])
print(paste0(as.character(nrow(trees_in))," trees in current tile"))

# convert from SF to Spatial object to use the raster::extract function
mrs4point_mainCanopy_Sp <- sf::as_Spatial(trees_in,
                                  IDs = as.character(trees_in$TreeNum))

# extract all layers for each pixel in the shapefile
extracted_spectra <- raster::extract(stacked_aop_data, 
                                     mrs4point_mainCanopy_Sp, 
                                     df = TRUE)

extracted_spectra$TreeNum <- mrs4point_mainCanopy_Sp$TreeNum
extracted_spectra$taxonID <- mrs4point_mainCanopy_Sp$taxonID

# Remove any spectra that have a height == 0
print(paste0(as.character(sum(extracted_spectra$chm==0)), 
               " pixels have a height of 0 in the CHM"))
print("Removing these rows from the training set ... ")
# also reset the factor levels (in case there are dropped taxonID levels)
extracted_spectra <- extracted_spectra %>% filter(chm>0) %>% droplevels()

# write extracted spectra to file 
extracted_features_filename <- paste0(out_dir, "MRS04_extracted_features.csv")
write.csv(extracted_spectra, 
          file = extracted_features_filename) 
```

The spectral reflectance values are stored in columns starting with "X" (for example, X552 corresponds to the 551.5494nm band in the hyperspectral data set). Create a lookup table that matches each column name with the corresponding wavelength. Remove the "bad bands" where atmospheric absorption is high. 

```{r rf}
# read text file containing wavelengths 
wavelengths = as.numeric(unlist(read.table(paste0(out_dir,"wavelengths.txt"),
                                           sep="\n",
                                           skip = 1,
                                           col.names = 'wavelength')))

# remove the band bands where atmospheric absorption leads to low SNR
remove_bands <- wavelengths[(wavelengths > bad_band_window_1[1] & 
                                 wavelengths < bad_band_window_1[2]) | 
                                (wavelengths > bad_band_window_2[1] & 
                                   wavelengths < bad_band_window_2[2])]
  
# create a LUT that matches actual wavelength values with the column names,
# X followed by the rounded wavelength values. Remove the rows that are 
# within thebad band ranges. 
wavelength_lut <- data.frame(wavelength = wavelengths,
                             xwavelength = paste0("X", 
                                                  as.character(round(wavelengths))),
                             stringsAsFactors = FALSE) 
```

## Ribbon Plot 

Compare the mean spectral reflectance per species. The shading represents +/- one standard deviation. 

```{r ribbon_plot, include = FALSE, results=TRUE}
# filter the columns to only keep those with spectral reflectance,
# which start with "X", for instance "X381", "X386"...
spectra_all <- extracted_spectra %>% 
  select( colnames(extracted_spectra)[ grepl( "X", names(extracted_spectra))] ) 
  
  
# calculate mean and standard deviation reflectance per species
mean_reflectance <- stats::aggregate(spectra_all, 
                                     by = list(taxonID = extracted_spectra$taxonID),
                                     FUN = mean) 
sd_reflectance <- stats::aggregate(spectra_all,
                                   by = list(taxonID = extracted_spectra$taxonID),
                                   FUN = sd)

# use the gather function makes wide data longer:
# https://uc-r.github.io/tidyr 
# so the reflectance data can easily be grouped by species, 
# and the mean/min/max reflectance values can be selected for a ribbon plot. 
mean_refl_tidy <- tidyr::gather(mean_reflectance,
                                key = xwavelength,
                                value = "mean_reflectance",
                                X381:X2510) %>%
  dplyr::left_join(wavelength_lut, by="xwavelength") 

# add on the SD reflectance columns with the same format 
sd_refl_tidy <- tidyr::gather(sd_reflectance,
                              key = xwavelength,
                              value = "sd_reflectance",
                              X381:X2510)

# combine the mean, min, man reflectance data into one long data frame
refl_tidy <- merge.data.frame(mean_refl_tidy,
                              sd_refl_tidy) %>% 
  select(-xwavelength) %>%          # remove the Xwavelength values 
  select(wavelength, everything())  # reorder to wavelength column is first


# remove the first reflectance value(s) which are often noisy 
refl_tidy <- refl_tidy[refl_tidy$wavelength > 385,]
# remove the bad bands 
refl_tidy$mean_reflectance[refl_tidy$wavelength %in% remove_bands] <- NA
refl_tidy$sd_reflectance[refl_tidy$wavelength %in% remove_bands] <- NA


# add and subtract one standard deviation from the mean 
refl_tidy$mean_plus_sd <- refl_tidy$mean_reflectance + refl_tidy$sd_reflectance
refl_tidy$mean_minus_sd <- refl_tidy$mean_reflectance - refl_tidy$sd_reflectance
# set any negative values to zero for proper plotting 
refl_tidy$mean_minus_sd[refl_tidy$mean_minus_sd<0] <- 0

# specify the colors for the reflectance curves & shading around them 
shading_colors <- c("#d7191c", "#fdae61", "#abdda4", "#2b83ba")
species <- taxonList #alphabetical so colors match plot above
shading_alpha <- 0.4

# specify maximum y value for the spectral reflectance ribbon plots
y_max <- max(refl_tidy$mean_plus_sd)

# generate the ribbon plot
ggplot(refl_tidy, 
       aes(x = wavelength, y = mean_reflectance, color = taxonID)) + 
  
  # ABLAL
  geom_ribbon(data = refl_tidy[refl_tidy$taxonID == species[1], ],
              aes(ymin = mean_minus_sd,
                  ymax = mean_plus_sd), # std dev shading
              colour=NA,
              alpha = shading_alpha,
              fill = shading_colors[1],
              show.legend = F) + 
  
  # PICOL
  geom_ribbon(data = refl_tidy[refl_tidy$taxonID == species[2], ],
              aes(ymin = mean_minus_sd,
                  ymax = mean_plus_sd), # std dev shading
              colour=NA,
              alpha = shading_alpha,
              fill = shading_colors[2],
              show.legend = F) + 
  
  # PIEN
  geom_ribbon(data = refl_tidy[refl_tidy$taxonID == species[3], ],
              aes(ymin = mean_minus_sd,
                  ymax = mean_plus_sd), # std dev shading
              colour=NA,
              alpha = shading_alpha,
              fill = shading_colors[3],
              show.legend = F) + 
  
  # PIFL2
  geom_ribbon(data = refl_tidy[refl_tidy$taxonID == species[4], ],
              aes(ymin = mean_minus_sd,
                  ymax = mean_plus_sd), # std dev shading
              colour=NA,
              alpha = shading_alpha,
              fill = shading_colors[4],
              show.legend = F) + 
  
  
  # mean reflectance line
  # placing this after the ribbon shading so the mean curves are visible
  geom_line(size = 0.5, alpha = 1) + 
  
  scale_color_manual(values = shading_colors) + 
  
  # hide the "alpha" legend
  guides(alpha=FALSE) + 
  
  # label X and Y axes 
  labs(x = "wavelength (nm)", y = "reflectance") + 
  
  # set the y axis range to be consistent between plots
  ylim(0,y_max) + 
  
  # main plot title  
  ggtitle(paste0("MRS-04 Mean spectral reflectance per species: \n",
                 # std dev shading
                 "(shading shows one standard deviation from mean refl range per wavelength)"))

# write plot to file 
ggsave(paste0(out_dir,"/figures/","MRS04_ribbon_plot.png"), 
       width = 10, height = 6)

```

## Prepare the input data for RF classifier 

Select which features will be used.
Calculate Principal Components to reduce the dimensionality of the spectral reflectance data. 

```{r}
# read random forest classifier, variable name rf_model
load("../output/NIWO/rf_allSamplesPerClass_ntree5000_pca2InsteadOfWavelengths_nVar6/rf_model_allPolygons_halfDiameter.RData")

# features to use in the RF models.
# this list is used to filter the columns of the data frame,
# to remove the ones containing other metadata per tree from the model. 
featureNames <- c("taxonID", 
                  #wavelength_lut$xwavelength, # no need to keep bands since using PCA
                  "chm", 
                  "slope", 
                  "aspect",
                  "ARVI",
                  "EVI",
                  "NDLI",
                  "NDNI",
                  "NDVI",
                  "PRI",
                  "SAVI",
                  "rgb_meanR",
                  "rgb_meanG",
                  "rgb_meanB",
                  "rgb_mean_sd_R",
                  "rgb_mean_sd_G",
                  "rgb_mean_sd_B")

# PCA - Principal Component Analysis
# isolate the reflectance features
hs <- extracted_spectra %>% dplyr::select(c(wavelength_lut$xwavelength)) %>% as.matrix()
hs_pca <- stats::prcomp(hs, center = TRUE, scale. = TRUE)

#summary(hs_pca)
# This shows the proportion of variance explained by each PC.
# PC 1 - 0.7997
# PC 2 - 0.1608
# Cumulative proportion explained by PC1 and PC2: 0.9605

# filter the data to contain the features of interest 
features <- extracted_spectra %>% 
    dplyr::select(featureNames)

# add first n PCs to features data frame
nPCs <- 2
features <- cbind(features, hs_pca$x[,1:nPCs]) 


# visualize where each sample falls on a plot with PC2 vs PC1 
    ggbiplot::ggbiplot(hs_pca, 
                       choices = 1:2, # which PCs to plot
                       obs.scale = 1, var.scale = 1, # scale the observations and variables 
                       var.axes=FALSE, # remove arrows 
                       groups = extracted_spectra$taxonID, # color the points by species
                       ellipse = TRUE, # draw ellipse around each group
                       circle = TRUE # draw circle around center of data set
                        )   + 
      ggtitle("PCA biplot, PC1 and PC2") + 
      scale_color_brewer(palette="Spectral")
```

## Predict species using RF classifier 

```{r}
predValidation <- stats::predict(rf_model, features, type = "class")

confusionTable <- table(predValidation, features$taxonID)
print(confusionTable)

print(paste0("overall accuracy predicting validation set: ",
  as.character(sum(predValidation == features$taxonID) / length(features$taxonID))))
```

