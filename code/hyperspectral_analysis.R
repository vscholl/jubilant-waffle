# load necessary R packages 
library(rhdf5)
library(rgdal)
library(raster)
library(ggplot2)
library(tidyr)
library(sf)
library(dplyr)
library(data.table) 

# set working directory
setwd("~/github/jubilant-waffle/code/")

# load any local functions in external files 
source("supporting_functions.R")

# code for NEON site 
site_code <- 'NIWO'

# directory with hyperspectral .h5 files
h5_dir <- paste0('../data/', site_code, '/hyperspectral/')

# directory with shapefiles (tree stem locations and crown polygons)
shapefile_dir <- paste0('../data/', site_code, '/shapefiles/')

# define the output directory. If it doesn't exist already, create it.
check_create_dir('../output/') # create top level "output" directory
out_dir <- paste0('../output/', site_code, '/')
check_create_dir(out_dir) # create output folder for site

# define the "bad bands" wavelength ranges in nanometers, where atmospheric 
# absorption creates unreliable reflectance values. 
bad_band_window_1 <- c(1340, 1445)
bad_band_window_2 <- c(1790, 1955)

# read tree polygons file - circles are size of max crown diameter
tree_polygons <- rgdal::readOGR(dsn = shapefile_dir,
                                layer = "polygons_checked_overlap")

# read the tree stem locations file
tree_points <- rgdal::readOGR(dsn = shapefile_dir,
                              layer = "mapped_stems_final")

# half max crown diameter (“50_percent” shape files) ----------------------

# read in tree polygons file - circles have half size of crown diameter
# note that there are a different number of final polygons / stems when the
# diameter is changed. 
tree_polygons <- rgdal::readOGR(dsn = shapefile_dir,
                                         layer = "polygons_checked_overlap_50percent")


tree_points <- rgdal::readOGR(dsn = shapefile_dir,
                              layer = "mapped_stems_final_50percent")

out_dir <- paste0('../output/', site_code, '/diam50percent/')
check_create_dir(out_dir) # create output folder for site

# ------------------------------------------------------------------------



# convert polygons and tree locations to SF objects
tree_polygons_sf <- sf::st_as_sf(tree_polygons)
tree_points_sf <- sf::st_as_sf(tree_points) 

# isolate the tree location coordinates 
tree_coords <- tree_points_sf %>% 
  sf::st_coordinates() %>% 
  as.data.frame()

# add new columns for the tree location coordinates 
tree_points_sf$X <- tree_coords$X
tree_points_sf$Y <- tree_coords$Y

# add empty columns for the min and max coordinates for each polygon
tree_polygons_sf$xmin <- NA 
tree_polygons_sf$xmax <- NA 
tree_polygons_sf$ymin <- NA 
tree_polygons_sf$ymax <- NA 

# add the min, max X and Y values to each polygon for filtering 
for (i in 1:nrow(tree_polygons_sf)) {
  tree_polygons_sf$xmin[i] <- as.numeric(sf::st_bbox(tree_polygons_sf$geometry[i])[1])
  tree_polygons_sf$ymin[i] <- as.numeric(sf::st_bbox(tree_polygons_sf$geometry[i])[2])
  tree_polygons_sf$xmax[i] <- as.numeric(sf::st_bbox(tree_polygons_sf$geometry[i])[3])
  tree_polygons_sf$ymax[i] <- as.numeric(sf::st_bbox(tree_polygons_sf$geometry[i])[4])
}

# merge the polygons with tree locations;
# rename the geometry columns to be more descriptive 
tree_polygons_points <- merge(as.data.frame(tree_polygons_sf),
                              as.data.frame(tree_points_sf)
                              [,c("indvdID", "X","Y","geometry")],
                              by="indvdID") %>% 
  dplyr::rename(geometry.polygon = geometry.x, 
                geometry.point = geometry.y)





# loop through h5 files ---------------------------------------------------

# get the names of all HDF5 files to iterate through
h5_list <- list.files(path = h5_dir, full.names = TRUE)
h5_list <- h5_list[grepl("*.h5", h5_list)]

# loop through h5 files 
for (h5 in h5_list) {
  
  print(h5)
  
  # create a georeferenced rasterstack using the current hyperspectral tile
  s <- stack_hyperspectral(h5)
  
  # figure out which trees are within the current tile by 
  polygons_in <- tree_polygons_points %>% 
    dplyr::filter(xmin >= extent(s)[1] & 
                  xmax < extent(s)[2] & 
                  ymin >= extent(s)[3] & 
                  ymax < extent(s)[4])
  
  print(paste0(as.character(nrow(polygons_in))," polygons in current tile"))
  
  # if no polygons are within the current tile, skip to the next one
  if (nrow(polygons_in)==0){
    print("no trees located within current tile... skipping to next tile")
    next
  }
  
  # convert from SF obect to SpatialPolygons object for clipping
  polygons_in_sp <- sf::as_Spatial(polygons_in$geometry.polygon,
                                   IDs = as.character(polygons_in$indvdID))
  points_in_sp <- sf::as_Spatial(polygons_in$geometry.point,
                                 IDs = as.character(polygons_in$indvdID))
  
  ### clip the hyperspectral raster stack with the polygons within current tile.
  # the returned objects are data frames, each row corresponds to a pixel in the
  # hyperspectral imagery. The ID number refers to which polygon or point that 
  # the pixel belongs to. A large polygon will lead to many extracted pixels
  # (many rows in the output data frame)
  
  # stem point locations 
  extracted_point_spectra <- raster::extract(s, points_in_sp, df = TRUE)
  
  # checked_overlap polygons generated using the neon_veg workflow 
  extracted_polygon_spectra <- raster::extract(s, polygons_in_sp, df = TRUE)
  
  # the buffer parameter can be used to include cells around each point of a
  # given size. the buffer parameter can be specified as a vector of the length
  # of the number of points. 
  
  # maxCrownDiameter (buffer of (maxCrownDiameter / 2))
#  buffers_mxDm <- tree_polygons_points$crownDm / 2
#  extracted_spectra_buffer_mxDm <- raster::extract(s, 
#                                                   points_in_sp,
#                                                   buffer = buffers_mxDm,
#                                                   df = TRUE)
  
  # 50% max crown diameter (buffer of (maxCrownDiameter / 4))
  #buffers_50percent <- tree_polygons_points$crownDm / 4
  #extracted_spectra_buffer_50percentDm <- raster::extract(s, 
  #                                                 points_in_sp,
  #                                                 buffer = buffers_50percent,
  #                                                 df = TRUE)
  # GETTING WEIRD ERROR: 
  #Error in (function (..., deparse.level = 1)  : 
  #number of columns of matrices must match (see arg 6)
  
  # Try substituting this 50% buffer parameter instead with the polygons
  # created using neon_veg workflow with a 50% smaller diameter?????? 
  
  # 50% max crown diameter (buffer of (maxCrownDiameter / 4))
#  extracted_polygon_halfDiam_spectra <- raster::extract(s, polygons_halfDiam_in_sp, df = TRUE)
  
  
  
  ### write spectra to file 
  
    # stem point locations 
  # write_spectra_to_file(spectra = extracted_point_spectra,
  #                       polygons_in = polygons_in,
  #                       filename_out = paste0(out_dir,
  #                                             "spectral_reflectance_",
  #                                             as.character(s@extent[1]),"_",
  #                                             as.character(s@extent[3]),"_",
  #                                             "stem_points",
  #                                             ".csv"))
  
  # checked_overlap polygons generated using the neon_veg workflow 
#  write_spectra_to_file(spectra = as.data.frame(extracted_polygon_spectra),
#                        polygons_in = polygons_in,
#                        filename_out = paste0(out_dir,
#                                              "spectral_reflectance_",
#                                              as.character(s@extent[1]),"_",
#                                              as.character(s@extent[3]),"_",
#                                              "polygons_checked_overlap_max_diameter",
#                                              ".csv"))
  
  # maxCrownDiameter (buffer of (maxCrownDiameter / 2))
#  write_spectra_to_file(spectra = as.data.frame(extracted_spectra_buffer_mxDm),
#                        polygons_in = polygons_in,
#                        filename_out = paste0(out_dir,
#                                              "spectral_reflectance_",
#                                              as.character(s@extent[1]),"_",
#                                              as.character(s@extent[3]),"_",
#                                              "buffer_max_diameter",
#                                              ".csv"))

  # checked_overlap polygons generated using the neon_veg workflow,
  # 50% maxCrownDiameter size. 
  write_spectra_to_file(spectra = as.data.frame(extracted_polygon_spectra),
                        polygons_in = polygons_in,
                        filename_out = paste0(out_dir,
                        "spectral_reflectance_",
                        as.character(s@extent[1]),"_",
                        as.character(s@extent[3]),"_",
                        "polygons_checked_overlap_50percent_diameter",
                        ".csv"))  
  
  
}
  



# read and plot the spectra .csv files  -----------------------------------

# get a list of the .csv file per tile containing woody veg stemse
csvs <- list.files(out_dir, full.names = TRUE)

# csvs <- csvs[grepl("*000.csv", csvs)] # from back when there was only one collection of csvs

# specify a description that the different shapefile iterations are named by
out_description <- "stem_points" # stem point locations 
out_description <- "polygons_checked_overlap_max_diameter" # checked_overlap polygons
out_description <- "buffer_max_diameter" # buffer of (maxCrownDiameter / 2)
out_description <- "polygons_checked_overlap_50percent_diameter" # checked_overlap, 50% max crown diameter

# refine the output csv selection 
csvs <- csvs[grepl(paste0("*000_", out_description, ".csv"), csvs)]

# combine all .csv data into a single data frame 
for (i in 1:length(csvs)){
  print(csvs[i])
  csv <- read.csv(csvs[i])
  
  if(i==1){
    spectra_all <- csv
  } else {
    # add a bias value to the ID column, so in the end
    # the ID values will range from 1 to n_trees
    csv$ID <- csv$ID + max(spectra_all$ID)
    spectra_all <- rbind(spectra_all, csv)
  }
}

# remove the unneccessary column "X.1"
spectra_all <- spectra_all %>% dplyr::select(-X.1)

# write ALL the spectra to a single file 
write.csv(spectra_all,
          file=paste0(out_dir, site_code, "_spectral_reflectance_ALL_",
                      out_description,".csv"))

# write the exact wavelengths to file for future use 
write.table(data.frame(wavelengths = wavelengths),
            paste(out_dir,"wavelengths.txt"),
            sep="\n",
            row.names=FALSE)

# read wavelengths if not previously created
#wavelengths = read.table(paste(out.dir.spectra,"wavelengths.txt"),
#                         sep="\n",
#                         skip = 1,
#                         col.names = 'wavelength')





# ribbon plots for different shapefiles ------------------------------------------

shapefile_list <- c("stem_points",
                    "polygons_checked_overlap_50percent_diameter",
                   "polygons_checked_overlap_max_diameter",
                   "buffer_max_diameter")

# absolute maximum reflectance to set the same ylimit for the plots
y_max <- 0.35    #max(refl_tidy$max_reflectance, na.rm = TRUE)

for (out_description in shapefile_list){
  print(paste0("creating ribbon plot for ", out_description))
  
  fname <- paste0(out_dir, site_code, 
                        "_spectral_reflectance_ALL_", out_description, ".csv")
  spectra_all <- as.data.frame(read.csv(fname)) %>%  select(-X.1)
  
  # calculate mean reflectance per species
  # VS-NOTE: ADJUST THE COLUMN SELECTION to use names instead of indices (i.e. "10")
  mean_reflectance <- stats::aggregate(spectra_all[,10:ncol(spectra_all)], 
                                       by = list(taxonID = spectra_all$taxonID),
                                       FUN = mean) 
  min_reflectance <- stats::aggregate(spectra_all[,10:ncol(spectra_all)], 
                                      by = list(taxonID = spectra_all$taxonID),
                                      FUN = min) 
  max_reflectance <- stats::aggregate(spectra_all[,10:ncol(spectra_all)], 
                                      by = list(taxonID = spectra_all$taxonID),
                                      FUN = max) 
  sd_reflectance <- stats::aggregate(spectra_all[,10:ncol(spectra_all)],
                                         by = list(taxonID = spectra_all$taxonID),
                                         FUN = sd)
  
  # add and subtract 1 standard deviation from the mean. Keep taxon ID column.
  # mean_plus_sd <- cbind(taxonID = mean_reflectance$taxonID,
  #                       (mean_reflectance[2:ncol(mean_reflectance)] + 
  #                        sd_reflectance[2:ncol(mean_reflectance)]))
  # 
  # mean_minus_sd <- cbind(taxonID = mean_reflectance$taxonID,
  #                        (mean_reflectance[2:ncol(mean_reflectance)] - 
  #                        sd_reflectance[2:ncol(mean_reflectance)]))
  
  # create a LUT that matches actual wavelength values with the column names,
  # X followed by the rounded wavelength values. 
  wavelength_lut <- data.frame(wavelength = wavelengths,
                               xwavelength = paste0("X",as.character(round(wavelengths))),
                               stringsAsFactors = FALSE)
  
  # use the gather function makes wide data longer:
  # https://uc-r.github.io/tidyr 
  # so the reflectance data can easily be grouped by species, 
  # and the mean/min/max reflectance values can be selected for a ribbon plot. 
  mean_refl_tidy <- tidyr::gather(mean_reflectance,
                                  key = xwavelength,
                                  value = "mean_reflectance",
                                  X381:X2510) %>%
    dplyr::left_join(wavelength_lut, by="xwavelength") 
  
  # add on the max, min reflectance columns with the same format 
  max_refl_tidy <- tidyr::gather(max_reflectance,
                                 key = xwavelength,
                                 value = "max_reflectance",
                                 X381:X2510)
  
  min_refl_tidy <- tidyr::gather(min_reflectance,
                                 key = xwavelength,
                                 value = "min_reflectance",
                                 X381:X2510)
  
  sd_refl_tidy <- tidyr::gather(sd_reflectance,
                                 key = xwavelength,
                                 value = "sd_reflectance",
                                 X381:X2510)
  
  # combine the mean, min, man reflectance data into one long data frame
  refl_tidy <- merge.data.frame(mean_refl_tidy,
                                max_refl_tidy) %>% 
    merge.data.frame(min_refl_tidy) %>% 
    merge.data.frame(sd_refl_tidy) %>% 
    select(-xwavelength) %>%          # remove the Xwavelength values 
    select(wavelength, everything())  # reorder to wavelength column is first
  
  
  
  # remove the first reflectance value 
  refl_tidy <- refl_tidy[refl_tidy$wavelength > 385,]
  
  # remove the bad bands 
  refl_tidy$mean_reflectance[refl_tidy$wavelength %in% remove_bands] <- NA
  refl_tidy$max_reflectance[refl_tidy$wavelength %in% remove_bands] <- NA
  refl_tidy$min_reflectance[refl_tidy$wavelength %in% remove_bands] <- NA
  
  # specify the colors for the reflectance curves & shading around them 
  shading_colors <- c("#d7191c", "#fdae61", "#abdda4", "#2b83ba")
  species <- sort(unique(spectra_all$taxonID)) #alphabetical so colors match plot above
  shading_alpha <- 0.4
  
  # generate the ribbon plot
  ggplot(refl_tidy, 
         aes(x = wavelength, y = mean_reflectance, color = taxonID)) + 
    
    # shaded ribbon from min to max for each species
    # can't get the shading colors to match the lines
    #geom_ribbon(aes(ymin = min_reflectance,
    #                ymax = max_reflectance,
    #                alpha = 0.1,
    #                fill = taxonID)) + 
    
    # ABLAL
    geom_ribbon(data = refl_tidy[refl_tidy$taxonID == species[1], ],
                #aes(ymin = min_reflectance, ymax = max_reflectance), # min max shading
                #aes(ymin = mean_minus_sd[mean_minus_sd$taxonID == species[1], ], 
                #    ymax = mean_plus_sd[mean_plus_sd$taxonID == species[1], ]), # std dev shading
                aes(ymin = mean_reflectance - sd_reflectance,
                    ymax = mean_reflectance + sd_reflectance), # std dev shading
                colour=NA,
                alpha = shading_alpha,
                fill = shading_colors[1],
                show.legend = F) + 
    
    # PICOL
    geom_ribbon(data = refl_tidy[refl_tidy$taxonID == species[2], ],
                #aes(ymin = min_reflectance, ymax = max_reflectance), # min max shading
                aes(ymin = mean_reflectance - sd_reflectance,
                    ymax = mean_reflectance + sd_reflectance), # std dev shading
                colour=NA,
                alpha = shading_alpha,
                fill = shading_colors[2],
                show.legend = F) + 
    
    # PIEN
    geom_ribbon(data = refl_tidy[refl_tidy$taxonID == species[3], ],
                # aes(ymin = min_reflectance, ymax = max_reflectance), # min max shading
                aes(ymin = mean_reflectance - sd_reflectance,
                    ymax = mean_reflectance + sd_reflectance), # std dev shading
                colour=NA,
                alpha = shading_alpha,
                fill = shading_colors[3],
                show.legend = F) + 
    
    # PIFL2
    geom_ribbon(data = refl_tidy[refl_tidy$taxonID == species[4], ],
                # aes(ymin = min_reflectance, ymax = max_reflectance), # min max shading
                aes(ymin = mean_reflectance - sd_reflectance,
                    ymax = mean_reflectance + sd_reflectance), # std dev shading
                colour=NA,
                alpha = shading_alpha,
                fill = shading_colors[4],
                show.legend = F) + 
    
    
    # mean reflectance line
    # placing this after the ribbon shading so the mean curves are visible
    geom_line(size = 0.5, alpha = 1) + 
    
    scale_color_manual(values = shading_colors) + 
    
    # hide the "alpha" legend
    guides(alpha=FALSE) + 
    
    # label X and Y axes 
    labs(x = "wavelength (nm)", y = "reflectance") + 
    
    # set the y axis range to be consistent between plots
    ylim(0,y_max) + 
    
    # main plot title  
    ggtitle(paste0("Mean Hyperspectral reflectance per species: ", out_description, " \n",
                   #"(shading shows minimum and maximum refl range per wavelength)")) # min max shading
                   "(shading shows one standard deviation from mean refl range per wavelength)")) # std dev shading
                   
                   
  ggsave(paste0(out_dir,"/figures/","ribbon_plot_", out_description, ".png"), width = 10, height = 6)
  
}






# Testing: crop HS data using single polygon ------------------------------

# read wavelengths
wavelengths = as.numeric(unlist(read.table(paste0(out_dir,"wavelengths.txt"),
                                           sep="\n",
                                           skip = 1,
                                           col.names = 'wavelength')))


p <- polygons_in_sp[1]
h5_cropped <- raster::crop(s, p)
dim(h5_cropped)

# get indices of RGB bands within the raster stack 
wl_r <- which.min(abs(wavelengths - 669)) # R 
wl_g <- which.min(abs(wavelengths - 549)) # G 
wl_b <- which.min(abs(wavelengths - 474)) # B 

h5_rgb <- raster::subset(h5_cropped, subset = c(wl_r, wl_g, wl_b)) 


plotRGB(h5_rgb,
        r = 1, g = 2, b = 3,
        stretch = "hist",
        axes = TRUE,
        main="RGB Composite",
        xlab="Easting (m)",
        ylab="Northing (m)",
        cex.main=2)

# write cropped RGB RasterBrick to a tif
writeRaster(h5_rgb,
            paste0(out_dir,"myStack.tif"), 
            format="GTiff",
            overwrite=TRUE)

