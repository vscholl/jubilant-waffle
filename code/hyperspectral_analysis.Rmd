---
title: "Hyperspectral Analysis"
author: "Victoria Scholl"
date: "12/27/2018"
output: 
  html_document:
    theme: cosmo
    highlight: zenburn
---

## Introduction

This document outlines the workflow that integrates field-based tree measurements with airborne remote sensing data from the National Ecological Observatory Network (NEON). Using points and polygons generated using the [neon_veg](https://github.com/earthlab/neon-veg) workflow, this R code extracts reflectance values for each tree from hyperspectral image data and performs subsequent spectral analysis. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE,
                      results = 'hide')
```

# Extract reflectance spectra 

## Setup 

First, load the required R packages for this analysis. 

```{r load_packages}
# load necessary R packages 
library(rhdf5)
library(rgdal)
library(raster)
library(ggplot2)
library(tidyr)
library(sf)
library(dplyr)
library(data.table) 
library(knitr) # for nice table formatting
library(kableExtra)
library(RColorBrewer)

# set working directory
setwd("~/github/jubilant-waffle/code/")

# load any local functions in external files 
source("supporting_functions.R")
```

```{r study_area_map}
library(maps)
# plot study area with context on the US map, highlight california 
maps::map('state', fill = TRUE, col = "darkgray", border = "white", lwd = 1)
maps::map(database = "usa", lwd = 1, add = TRUE)
maps::map("state", "colorado", col = "coral1",
    lwd = 1, fill = TRUE, add = TRUE)

# add the NIWO site location
title("Study Area: Niwot Ridge Mountain Research Station (NIWO)\nColorado, NEON Domain 13, Southern Rockies & Colorado Plateau")

# add the x, y location of the SJER using the points
points(x = -105.48237, y = 40.05425, pch = 0, col = "black", cex = 1.3, lwd = 1.5)


```

Specify where the hyperspectral data and shapefiles are located. 

* This project is currently structured with "code", "data", and "output" top-level directories.
* Within "data", each NEON site has its own directory named with the site code (such as "NIWO" for Niwot Ridge). 
* The polygon and point shapefiles will be used to clip hyperspectral data to obtain spectral reflectance for each tree location. 

```{r directory_input_output}
# code for NEON site 
site_code <- 'NIWO'

# directory with hyperspectral .h5 files
h5_dir <- paste0('../data/', site_code, '/hyperspectral/')

# directory with shapefiles (tree stem locations and crown polygons)
shapefile_dir <- paste0('../data/', site_code, '/shapefiles/')

# define the output directory. If it doesn't exist already, create it.
check_create_dir('../output/') # create top level "output" directory
check_create_dir(paste0('../output/', site_code, '/figures')) # folder for plots
out_dir <- paste0('../output/', site_code, '/')
check_create_dir(out_dir) # create output folder for site

# define the "bad bands" wavelength ranges in nanometers, where atmospheric 
# absorption creates unreliable reflectance values. 
# --> Instead, read the bad band ranges from metadata?
bad_band_window_1 <- c(1340, 1445)
bad_band_window_2 <- c(1790, 1955)
```

## Read and pre-process vector data 

Read the shapefiles.
The circular crown poylgons are read in as a SpatialPolygonsDataFrame.
The tree stem locations are read in as a SpatialPointsDataFrame. 
After following the [neon_veg](https://github.com/earthlab/neon-veg) workflow, the *polygons_checked_overlap* shapefile contains polygons that have been checked for overlap with neighboring polygons, preserving those that are most likely visible in the airborne imagery. The *mapped_stems_final* shapefile contains the point locations of the corresponding tree stems. 

```{r read_shapefiles}
# read tree polygons file 
tree_polygons <- rgdal::readOGR(dsn = shapefile_dir,
                           layer = "polygons_checked_overlap")

# read the tree stem locations file
tree_points <- rgdal::readOGR(dsn = shapefile_dir,
                              layer = "mapped_stems_final")
```

For later analysis, these Spatial data frames can be converted to SF objects and additional columns are added to contain the extent information for each tree polygon. 

```{r convert_shapefiles}
# convert polygons and tree locations to SF objects
tree_polygons_sf <- sf::st_as_sf(tree_polygons)
tree_points_sf <- sf::st_as_sf(tree_points) 

# isolate the tree location coordinates 
tree_coords <- tree_points_sf %>% 
  sf::st_coordinates() %>% 
  as.data.frame()

# add new columns for the tree location coordinates 
tree_points_sf$X <- tree_coords$X
tree_points_sf$Y <- tree_coords$Y

# add empty columns for the min and max coordinates for each polygon
tree_polygons_sf$xmin <- NA 
tree_polygons_sf$xmax <- NA 
tree_polygons_sf$ymin <- NA 
tree_polygons_sf$ymax <- NA 

# add the min, max X and Y values to each polygon for filtering 
for (i in 1:nrow(tree_polygons_sf)) {
  tree_polygons_sf$xmin[i] <- as.numeric(sf::st_bbox(tree_polygons_sf$geometry[i])[1])
  tree_polygons_sf$ymin[i] <- as.numeric(sf::st_bbox(tree_polygons_sf$geometry[i])[2])
  tree_polygons_sf$xmax[i] <- as.numeric(sf::st_bbox(tree_polygons_sf$geometry[i])[3])
  tree_polygons_sf$ymax[i] <- as.numeric(sf::st_bbox(tree_polygons_sf$geometry[i])[4])
}

# merge the polygons with tree locations;
# rename the geometry columns to be more descriptive 
tree_polygons_points <- merge(as.data.frame(tree_polygons_sf),
                         as.data.frame(tree_points_sf)
                         [,c("indvdID", "X","Y","geometry")],
                         by="indvdID") %>% 
  dplyr::rename(geometry.polygon = geometry.x, 
                geometry.point = geometry.y)
```

## Read and pre-process raster data 

The hyperspectral data is available in 1km x 1km square tiles.

Read the first tile metadata and reflectance data. 

```{r read_hyperspectral}
# get the names of all HDF5 files to iterate through
h5_list <- list.files(path = h5_dir, full.names = TRUE)
h5_list <- h5_list[grepl("*.h5", h5_list)]

# select first HDF5 file 
h5 <- h5_list[1]
print(h5)

# list the contents of HDF5 file
h5_struct <- rhdf5::h5ls(h5, all=T)

# construct the string using "/Reflectance/Metadata/Coordinate_System",
# without explicitly using a site code 
crs_tag <- h5_struct$group[grepl("/Reflectance/Metadata/Coordinate_System", 
                                 h5_struct$group)][1] 

# read coordinate reference system data
crs_info <- rhdf5::h5read(h5, crs_tag)

# convert "UTM" to lowercase "utm" for proper usage later
crs_info$Proj4 <- CRS(chartr("UTM", "utm", crs_info$Proj4))

# get attributes for the Reflectance dataset.
# construct the string using "/Reflectance/Reflectance_Data"" 
refl_tag <- paste0(h5_struct$group[grepl("/Reflectance", 
                                         h5_struct$group)][1],
                   "/Reflectance_Data")

# read the reflectance metadata
refl_info <- rhdf5::h5readAttributes(h5,refl_tag)

# get the dimensions of the reflectance data
n_rows <- refl_info$Dimensions[1]
n_cols <- refl_info$Dimensions[2]
n_bands <- refl_info$Dimensions[3]

# print dimensions 
print(paste0("# Rows: ", as.character(n_rows)))
print(paste0("# Columns: ", as.character(n_cols)))
print(paste0("# Bands: ", as.character(n_bands)))

# read the wavelengths of the hyperspectral image bands
wavelength_tag <- paste0(h5_struct$group[grepl("/Reflectance/Metadata/Spectral_Data", 
                                               h5_struct$group)][1],
                         "/Wavelength")
wavelengths <- rhdf5::h5read(h5,
                             wavelength_tag)

# define spatial extent: extract resolution and origin coordinates
map_info <- unlist(strsplit(crs_info$Map_Info, 
                            split = ", "))
res_x <- as.numeric(map_info[6])
res_y <- as.numeric(map_info[7])
x_min <- as.numeric(map_info[4])
y_max <- as.numeric(map_info[5])

# calculate the maximum X and minimum Y values 
x_max <- (x_min + (n_cols * res_x))
y_min <- (y_max - (n_rows * res_y))
tile_extent <- raster::extent(x_min, x_max, y_min, y_max)

# read reflectance data for all bands
refl <- rhdf5::h5read(h5, refl_tag,
                      index = list(1:n_bands, 1:n_cols, 1:n_rows))

# view and apply scale factor to convert integer values to reflectance [0,1]
# and data ignore value
scale_factor <- refl_info$Scale_Factor
data_ignore <- refl_info$Data_Ignore_Value
refl[refl == data_ignore] <- NA 
refl_scaled <- refl / scale_factor
```

## Extract reflectance spectra for each tree from hyperspectral imagery 

As this [Earth Lab tutorial](https://www.earthdatascience.org/courses/earth-analytics/lidar-raster-data-r/crop-raster-data-in-r/) describes, there is an **extract** function within the **raster** R package. It requires raster and and vector objects. 

As for the vector layers, let's figure out which trees are within the current tile and convert their corresponding points and polygons from SF objects to SpatialPoints and SpatialPolygons forms. 

```{r polygons_in_tile}
# figure out which trees are within the current tile 
polygons_in <- tree_polygons_points %>% 
  dplyr::filter(xmin >= tile_extent@xmin & 
                xmax < tile_extent@xmax & 
                ymin >= tile_extent@ymin & 
                ymax < tile_extent@ymax)

print(paste0(as.character(nrow(polygons_in))," polygons in current tile"))

# if no polygons are within the current tile, skip to the next one
if (nrow(polygons_in)==0){
  print("no trees located within current tile... skipping to next tile")
  next
}

# convert from SF obect to SpatialPolygons object for clipping
polygons_in_sp <- sf::as_Spatial(polygons_in$geometry.polygon,
                                 IDs = as.character(polygons_in$indvdID))
points_in_sp <- sf::as_Spatial(polygons_in$geometry.point,
                                 IDs = as.character(polygons_in$indvdID))

```

Let's stack up all of the hyperspectral bands into a RasterStack (a collection of Raster layers with the same spatial resolution and extent) as the raster input to this function. 

```{r create_hyperspectral_rasterstack}

# create georeferenced raster using band 1 
r1 <- (refl_scaled[1,,]) # convert first band to matrix
r1 <- raster::raster(r1, crs = crs_info$Proj4)
extent(r1) <- tile_extent

# start the raster stack with first band 
s <- raster::stack(r1)

# loop through bands and create a giant rasterstack with 426 (n_bands) bands
for(b in 2:n_bands){
  print(b)
  
  # create raster with current band
  r <- (refl_scaled[b,,]) # convert to matrix
  r <- raster::raster(r, crs = crs_info$Proj4)
  extent(r) <- tile_extent
  
  # add additional band to the stack with the addLayer function
  s <- raster::addLayer(s, r)
  
}

# adjust the names for each layer in raster stack to correspond to wavelength
names(s) <- round(wavelengths)
```

Let's clip the scaled hyperspectral reflectance rasterstack with the tree polygons to extract reflectance curves for each tree stem point, and within each polygon area. 

```{r extract_rasterstack_spectra}
# clip the hyperspectral raster stack with the polygons within current tile.
# the returned objects are data frames, each row corresponds to a pixel in the
# hyperspectral imagery. The ID number refers to which polygon or point that 
# the pixel belongs to. A large polygon will lead to many extracted pixels
# (many rows in the output data frame)
extracted_point_spectra <- raster::extract(s, points_in_sp, df = TRUE)
extracted_polygon_spectra <- raster::extract(s, polygons_in_sp, df = TRUE)
```

In the resulting data frames, each row contains a single reflectance spectrum, corresponding to a single pixel location (x,y) in the hyperspectral imagery. 

* In the **extracted_point_spectra**, there is one row per tree stem.
* In the **extracted_polygon_spectra**, there are multiple rows per tree polygon. A larger polygon will intersect with more pixels, producing more rows for trees with large crowns in this output data frame. 
* The "ID" column contains an integer to identify which of the trees within the tile that the spectra belong to. 

For instance, let's take a look at the first 12 rows of the extracted_point_spectra. Thee first 5 columns are displayed here, which contain "ID" values and the first few reflectance values for low wavelengths around 380nm. Notice that the ID column contains values that increase monotonically with rows for the extracted point spectra, since each tree stem point intersects with a single pixel in the hyperspectral imagery. 

```{r head_point_spectra, results = TRUE}
head(extracted_point_spectra[,1:5], n = 12)
```

The first 12 rows of the extracted_polygon_spectra look different (specifically, the **ID** column). Rows 1 through 10 have an ID of 1. This means that tree 1 in the SpatialPolygons object intersected with 10 pixels in the hyperspectral imagery, so there are 10 spectra available for analysis. Tree 2 in the SpatialPolygons object intersects with more than 1 pixel too. We can see the beginning of those spectra in rows 11 and 12 below. 

```{r head_polygon_spectra, results = TRUE}
head(extracted_polygon_spectra[,1:5], n = 12)
```


Write the spectral reflectance data to file for each tree. Combine each spectrum with more information about each corresponding tree (including the individual ID, species, and height).
For the extracted spectra with more than one row per tree, adjust the "ID" column to reflect how many spectra correspond to each tree. 

```{r combine_metadata_write_spectra, results = TRUE}

# create polygon metadata data frame 
polygon_metadata <- data.frame(individualID = polygons_in$indvdID,
                              scientificName = polygons_in$scntfcN,
                              taxonID = polygons_in$taxonID,
                              maxCrownDiameter = polygons_in$crownDm,
                              height = polygons_in$height,
                              X = polygons_in$X,
                              Y = polygons_in$Y,
                              # create ID column to pair the polygon metadata with  spectra
                              ID =  1:nrow(polygons_in))

# create a list of increasing integer counts to keep track of how many rows 
# (pixels or spectra) belong to each tree 
for (i in unique(extracted_polygon_spectra$ID)){
  if(i==1){
    counts = 1:sum(extracted_polygon_spectra$ID==i)
  }
  else{
    counts = append(counts, 1:sum(extracted_polygon_spectra$ID==i))
  }
}

# combine the additional data with each spectrum for writing to file
spectra_write <- merge(polygon_metadata,
                       as.data.frame(extracted_polygon_spectra),
                       by="ID") %>% 
  mutate(spectra_count = counts)%>% 
  select(ID, spectra_count, everything())
  
# take a look at the first rows of the spectra data to write 
head(spectra_write[,1:10] %>% select(-c(scientificName,X,Y)))


# write the spectral data to file for future analysis 
write.csv(spectra_write, file = paste0(out_dir,
                                       "spectral_reflectance_",
                                        as.character(tile_extent@xmin),"_",
                                        as.character(tile_extent@ymin),".csv")) 
  
```

The accompanying *hyperspectral_analysis.R* script loops through all of the HDF5 files and extracts spectra using the steps described above. The spectra are written to separate .csv files for each tile, then combined into a single .csv tile for subsequent analysis. 

The code below reads the .csv file with all spectra for different types of shapefiles.

(1) All of the spectra extracted at **each stem location** (in theory, the central pixel per tree crown). *One pixel extracted per tree.*

(2) All of the spectra ectracted within the **"checked_overlap" polygons** generated by the neon_veg workflow. *The number of spectra per tree is based on the size/location of each polygon and how many pixels it intersects with.* Since these polygons may be clipped based on their proximity and height compared to neighboring trees, there will be fewer polygons for this scenario compared to the next. 

(3) All of the spectra extracted using the **"buffer" argument** in the raster::extract function. The buffer size was set based on the max_diameter of each tree crown. *The number of spectra per tree is based on the size/location of each polygon and how many pixels it intersects with.* 

```{r read_all_spectra}
# read all of the reflectance spectra extracted for all trees in current site.
# remove the column labeled "X.1", which just has row numbers. 


# (1) stem point locations 
out_description <- "stem_points" # stem point locations 
spectra_all_points_filename <- paste0(out_dir, 
                                             site_code,
                                             "_spectral_reflectance_ALL_",
                                              out_description, ".csv")
spectra_all_points <- as.data.frame(read.csv(spectra_all_points_filename)) %>% 
                  select(-X.1)


# (2) checked_overlap polygons
out_description <- "polygons_checked_overlap_max_diameter" # checked_overlap polygons
spectra_all_overlapPolygons_filename <- paste0(out_dir, 
                                             site_code,
                                             "_spectral_reflectance_ALL_",
                                              out_description, ".csv")
spectra_all_overlapPolygons <- as.data.frame(read.csv(spectra_all_overlapPolygons_filename)) %>% 
                  select(-X.1)


# (3) buffer_max_diameter
out_description <- "buffer_max_diameter" # buffer of (maxCrownDiameter / 2)
spectra_all_bufferPolygons_filename <- paste0(out_dir, 
                                             site_code,
                                             "_spectral_reflectance_ALL_",
                                              out_description, ".csv")
spectra_all_bufferPolygons <- as.data.frame(read.csv(spectra_all_bufferPolygons_filename)) %>% 
                  select(-X.1)




spectra_all <- spectra_all_points
spectra_all_overlapPolygons <- spectra_all_overlapPolygons
# filter the spectra to reduce the number of them for quick visualization 
# figure out how to extract spectra for the center pixels most efficiently, make a 
# function out of hyperspectral_analysis.R? 
#set.seed(12)
#spectra_all <- spectra_all[sample(nrow(spectra_all), size = 100),]
#spectra_all <- spectra_write # use the single tile spectra from above for quick viz 
```



# Spectral Analysis

## Plot reflectance spectra

Plot the reflectance spectra as a function of wavelength. First, let's see them all on a single graph, colored by species.

For reference, here is a table detailing the scientific names, common names, taxon ID values, and number of tree stems present in the data set for each of the four species present at the Niwot Ridge site: 

```{r species_table, echo=FALSE, results=TRUE}
library(knitr)
library(kableExtra)
species_table <- data.table("TaxonID" = c("ABLAL",
                                           "PICOL",
                                           "PIEN",
                                           "PIFL2"),
                            "Scientific name" = c("Abies lasiocarpa",
                                                  "Pinus contorta",
                                                  "Picea engelmannii",
                                                  "Pinus flexilis"),
                            "Common Name" = c("Subalpine fir",
                                              "Lodgepole pine",
                                              "Engelmann spruce",
                                              "Limber pine"),
                            "Number of stems" = as.data.frame(table(tree_points$taxonID))$Freq)

knitr::kable(species_table) %>% kable_styling(bootstrap_options = c("striped", "hover"))
```


```{r plot_spectra}

# keep just the reflectance values along with individual ID and species
# for the first tree
spectra_1 <- spectra_all[1,] %>% 
                dplyr::select(-c(X,Y,ID))

# organize the data into a data frame where the first column contains
# the individualID, second column contains scientific name, 
# followed by additional tree metadata and finally
# reflectance per wavelength.  
spectra_plot <- tidyr::gather(spectra_1,
                              key = wavelength,
                              value = "reflectance",
                              -individualID,
                              -scientificName,
                              -taxonID,
                              -maxCrownDiameter,
                              -height,
                              -spectra_count)
# add the actual wavelenth values into the wavelengths column
spectra_plot$wavelength <- wavelengths

# loop through the remaining spectra and repeat 
for (i in 2:nrow(spectra_all)){
  spectra_current <- spectra_all[i,] %>% 
                        dplyr::select(-c(X,Y,ID))
  spectra_current <- tidyr::gather(spectra_current,
                                key = wavelength,
                                value = "reflectance",
                                -individualID,
                                -scientificName,
                                -taxonID,
                                -maxCrownDiameter,
                                -height,
                                -spectra_count)
  spectra_current$wavelength <- wavelengths
  
  spectra_plot <- rbind(spectra_plot, spectra_current)
  
}

# remove the first reflectance value 
spectra_plot <- spectra_plot[spectra_plot$wavelength > 385,]

# remove the bad bands 
remove_bands <- wavelengths[(wavelengths > bad_band_window_1[1] & 
                            wavelengths < bad_band_window_1[2]) | 
                           (wavelengths > bad_band_window_2[1] & 
                            wavelengths < bad_band_window_2[2])]

spectra_plot$reflectance[spectra_plot$wavelength %in% remove_bands] <- NA
```

```{r point_spectra_single_plot, results=TRUE}
# plot all spectra on single plot 
# adjust line width and alpha for better visibility with many curves
ggplot(data = spectra_plot, 
       aes(x = wavelength, 
           y = reflectance, 
           colour = taxonID)) +
  geom_line(aes(group = individualID), size = 0.5, alpha = 0.7) + 
  labs(x = "wavelength (nm)", 
       color = "species") + 
  ggtitle("Hyperspectral reflectance extracted per pixel") +
          scale_color_manual(values = c("#d7191c", "#fdae61", "#abdda4", "#2b83ba")
  )
```

We can also plot the reflectance spectra on four separate plots, one per species. 

```{r point_spectra_multi_plot, results=TRUE}
# Use facet_grid for a separate plot per species 
ggplot(data = spectra_plot, 
       aes(x = wavelength, 
           y = reflectance, 
           colour = taxonID)) +
  geom_line(aes(group = individualID), alpha = 0.5) + 
  facet_wrap(. ~ taxonID, ncol = 2) + 
  labs(x = "wavelength (nm)", color = "species") + 
  ggtitle("Hyperspectral reflectance extracted per pixel") + 
  scale_color_manual(values = c("#d7191c", "#fdae61", "#abdda4", "#2b83ba"))
```

We can also plot all of the spectra for a single species in a single figure:

```{r results=TRUE}
# keep only the Engelmann spruce trees.
# give each curve its own color to help visualize some of the different shapes
ggplot(data = spectra_plot %>% filter(taxonID == "PIEN"), 
       aes(x = wavelength, 
           y = reflectance, 
           colour = individualID)) +
  geom_line(aes(group = individualID), size = 0.5, alpha = 0.5) + 
  labs(x = "wavelength (nm)") + 
  ggtitle("Hyperspectral reflectance curves, Engelmann Spruce") +
  theme(legend.position="none") # remove legend 
```



To assess the difference between a single stem location and a collection of pixels within a tree crown polygon, let's plot a single reflectance spectrum compared to a series of them. 

```{r plot_compare_point_polygon}
# all reflectance spectra for a tree polygon
j <- 25 # select an individual tree 
spectra_tree <- spectra_plot %>% 
              filter(individualID==as.character(unique(spectra_plot$individualID)[j])) 

# single reflectance spectrum for a tree stem point
spectrum_tree <- spectra_tree %>% 
                  filter(spectra_count == spectra_tree$spectra_count[1])

# plot reflectance spectrum for a single tree stem location pixel 
ggplot(data = spectrum_tree, 
       aes(x = wavelength, 
           y = reflectance, 
           colour = taxonID)) +
  geom_line(aes(group = individualID), size = 0.5, alpha = 1) + 
  labs(x = "wavelength (nm)") + 
  ggtitle(paste0("Hyperspectral reflectance for a single pixel, tree ",
                 as.character(unique(spectra_plot$individualID)[j]))) +
          scale_color_manual(values = c("#1c9099")
  )



# for this plot, use the polygon spectra
spectra_subset_overlapPolygons <- spectra_all_overlapPolygons %>% 
  filter(individualID==as.character(unique(spectra_plot$individualID)[j]))

spectra_1_overlapPolygons <- spectra_subset_overlapPolygons[1,] %>% 
                dplyr::select(-c(X,Y,ID))

spectra_plot_overlapPolygons <- tidyr::gather(spectra_1_overlapPolygons,
                              key = wavelength,
                              value = "reflectance",
                              -individualID,
                              -scientificName,
                              -taxonID,
                              -maxCrownDiameter,
                              -height,
                              -spectra_count)

spectra_plot_overlapPolygons$wavelength <- wavelengths

# loop through the remaining spectra and repeat 
for (i in 2:nrow(spectra_subset_overlapPolygons)){
  spectra_current <- spectra_subset_overlapPolygons[i,] %>% 
                        dplyr::select(-c(X,Y,ID))
  spectra_current <- tidyr::gather(spectra_current,
                                key = wavelength,
                                value = "reflectance",
                                -individualID,
                                -scientificName,
                                -taxonID,
                                -maxCrownDiameter,
                                -height,
                                -spectra_count)
  spectra_current$wavelength <- wavelengths
  
  spectra_plot_overlapPolygons <- rbind(spectra_plot_overlapPolygons, 
                                        spectra_current)
  
}

# remove the first reflectance value 
spectra_plot_overlapPolygons <- spectra_plot_overlapPolygons[spectra_plot_overlapPolygons$wavelength > 385,]

# remove the bad bands 
spectra_plot_overlapPolygons$reflectance[spectra_plot_overlapPolygons$wavelength %in% remove_bands] <- NA


# plot containing multiple pixels within a tree polygon
ggplot(data = spectra_plot_overlapPolygons, 
       aes(x = wavelength, 
           y = reflectance,
           colour = as.factor(spectra_count))) +
  geom_line(aes(group = spectra_count), size = 0.5, alpha = 1) + 
  labs(x = "wavelength (nm)", color = "spectra count") + 
  ggtitle(paste0("Hyperspectral reflectance for multiple pixels intersecting with polygon, \n tree ",
          as.character(unique(spectra_plot$individualID)[j]))) +
  scale_color_manual(values = brewer.pal(length(unique(spectra_plot_overlapPolygons$spectra_count)),
                                         "Set1"))
```



To visualize the variation of spectra per species, let's add shadded regions to capture the minimum and maximum reflectance per wavelength and see if there are any notable divergences between species. 

```{r ribbon_plot, results=TRUE}

# calculate mean reflectance per species
mean_reflectance <- stats::aggregate(spectra_all[,10:ncol(spectra_all)], 
                                     by = list(taxonID = spectra_all$taxonID),
                                     FUN = mean) 
min_reflectance <- stats::aggregate(spectra_all[,10:ncol(spectra_all)], 
                                     by = list(taxonID = spectra_all$taxonID),
                                     FUN = min) 
max_reflectance <- stats::aggregate(spectra_all[,10:ncol(spectra_all)], 
                                     by = list(taxonID = spectra_all$taxonID),
                                     FUN = max) 

# create a LUT that matches actual wavelength values with the column names,
# X followed by the rounded wavelength values. 
wavelength_lut <- data.frame(wavelength = wavelengths,
                             xwavelength = paste0("X",as.character(round(wavelengths))),
                             stringsAsFactors = FALSE)

# use the gather function makes wide data longer:
# https://uc-r.github.io/tidyr 
# so the reflectance data can easily be grouped by species, 
# and the mean/min/max reflectance values can be selected for a ribbon plot. 
mean_refl_tidy <- tidyr::gather(mean_reflectance,
                                key = xwavelength,
                                value = "mean_reflectance",
                                X381:X2510) %>%
  dplyr::left_join(wavelength_lut, by="xwavelength") 

# add on the min reflectance column with the same format 
max_refl_tidy <- tidyr::gather(max_reflectance,
                                key = xwavelength,
                                value = "max_reflectance",
                                X381:X2510)

min_refl_tidy <- tidyr::gather(min_reflectance,
                                key = xwavelength,
                                value = "min_reflectance",
                                X381:X2510)

# combine the mean, min, man reflectance data into one long data frame
refl_tidy <- merge.data.frame(mean_refl_tidy,
                              max_refl_tidy) %>% 
  merge.data.frame(min_refl_tidy) %>% 
  select(-xwavelength) %>%          # remove the Xwavelength values 
  select(wavelength, everything())  # reorder to wavelength column is first



# remove the first reflectance value 
refl_tidy <- refl_tidy[refl_tidy$wavelength > 385,]

# remove the bad bands 
refl_tidy$mean_reflectance[refl_tidy$wavelength %in% remove_bands] <- NA
refl_tidy$max_reflectance[refl_tidy$wavelength %in% remove_bands] <- NA
refl_tidy$min_reflectance[refl_tidy$wavelength %in% remove_bands] <- NA


# specify the colors for the reflectance curves & shading around them 
shading_colors <- c("#d7191c", "#fdae61", "#abdda4", "#2b83ba")
species <- sort(unique(spectra_all$taxonID)) #alphabetical so colors match plot above
shading_alpha <- 0.4

# generate the ribbon plot
ggplot(refl_tidy, 
       aes(x = wavelength, y = mean_reflectance, color = taxonID)) + 
      
      # shaded ribbon from min to max for each species
      # can't get the shading colors to match the lines
      #geom_ribbon(aes(ymin = min_reflectance,
      #                ymax = max_reflectance,
      #                alpha = 0.1,
      #                fill = taxonID)) + 
  
      # ABLAL
      geom_ribbon(data = refl_tidy[refl_tidy$taxonID == species[1], ],
                    aes(ymin = min_reflectance, ymax = max_reflectance),
                  colour=NA,
                  alpha = shading_alpha,
                  fill = shading_colors[1],
                  show.legend = F) + 
  
      # PICOL
      geom_ribbon(data = refl_tidy[refl_tidy$taxonID == species[2], ],
                    aes(ymin = min_reflectance, ymax = max_reflectance),
                  colour=NA,
                  alpha = shading_alpha,
                  fill = shading_colors[2],
                  show.legend = F) + 

      # PIEN
      geom_ribbon(data = refl_tidy[refl_tidy$taxonID == species[3], ],
                    aes(ymin = min_reflectance, ymax = max_reflectance),
                  colour=NA,
                  alpha = shading_alpha,
                  fill = shading_colors[3],
                  show.legend = F) + 
  
      # PIFL2
      geom_ribbon(data = refl_tidy[refl_tidy$taxonID == species[4], ],
                    aes(ymin = min_reflectance, ymax = max_reflectance),
                  colour=NA,
                  alpha = shading_alpha,
                  fill = shading_colors[4],
                  show.legend = F) + 

  
      # mean reflectance line
      # placing this after the ribbon shading so the mean curves are visible
      geom_line(size = 0.5, alpha = 1) + 
  
      scale_color_manual(values = shading_colors) + 
  
      # hide the "alpha" legend
      guides(alpha=FALSE) + 

      # label X and Y axes 
      labs(x = "wavelength (nm)", y = "reflectance") + 
  
      # main plot title  
      ggtitle(paste0("Mean Hyperspectral reflectance per species \n",
                    "(shading shows minimum and maximum refl range per wavelength)")) 

ggsave(paste0(out_dir,"/figures/","ribbon_plot.png"), width = 10, height = 6)

```

## Spectral seperability analysis

The [separability](https://www.rdocumentation.org/packages/spatialEco/versions/1.1-0/topics/separability) function within the SpatialEco R package calculates a variety of two-class sample separability metrics:

* *B* Bhattacharryya distance statistic (Bhattacharyya 1943; Harold 2003) - Measures the similarity of two discrete or continuous probability distributions.

* *JM* Jeffries-Matusita distance statistic  (Bruzzone et al., 2005; Swain et al., 1971) - The J-M distance is a function of separability that directly relates to the probability of how good a resultant classification will be. 

* *M* M-Statistic (Kaufman & Remer 1994) - This is a measure of the difference of the distributional peaks. A large M-statistic indicates good separation between the two classes as within-class variance is minimized and between-class variance maximized (M <1 poor, M >1 good).

* *D* Divergence index and *TD* Transformed Divergence index (Du et al., 2004) - Maximum likelihood approach. Transformed divergence gives an exponentially decreasing weight to increasing distances between the classes.




```{r results = TRUE}
# install.packages("spatialEco")
# library(spatialEco)
x <- as.numeric(mean_reflectance[1,2:length(wavelengths)]) # first row, ABLAB
y <- as.numeric(mean_reflectance[2,2:length(wavelengths)]) # second row, PICOL
sep <- spatialEco::separability(x, y, plot = TRUE)
  
# calculate seperability between each pair of species, for each polygon size 


# visualize using heat map https://www.r-graph-gallery.com/heatmap/ 

```

```{r seperability}
# Spectral seperability  --------------------------------------------------

# The [separability](https://www.rdocumentation.org/packages/spatialEco/versions/1.1-0/topics/separability) 
# function within the SpatialEco R package calculates a variety of two-class 
# sample separability metrics:
  
#  * *B* Bhattacharryya distance statistic (Bhattacharyya 1943; Harold 2003) - 
#        Measures the similarity of two discrete or continuous probability distributions.
#   * *JM* Jeffries-Matusita distance statistic (Bruzzone et al., 2005; Swain et al., 1971) - 
#          The J-M distance is a function of separability that directly relates to the 
#          probability of how good a resultant classification will be. 
#   * *M* M-Statistic (Kaufman & Remer 1994) - This is a measure of the difference of 
#          the distributional peaks. A large M-statistic indicates good separation 
#          between the two classes as within-class variance is minimized and 
#          between-class variance maximized (M <1 poor, M >1 good).
#   * *D* Divergence index and *TD* Transformed Divergence index (Du et al., 2004) - 
#         Maximum likelihood approach. Transformed divergence gives an exponentially 
#         decreasing weight to increasing distances between the classes.

# install.packages("spatialEco")
library(spatialEco)
x <- as.numeric(mean_reflectance[1,2:length(wavelengths)]) # first row, ABLAB
y <- as.numeric(mean_reflectance[2,2:length(wavelengths)]) # second row, PICOL
sep <- spatialEco::separability(x, y, plot = TRUE)
print(sep)

# calculate seperability between each pair of species, for each polygon size 


# create a list of each pair of species to compare seperability 
taxon_list <- as.character(mean_reflectance$taxonID)
# each column in taxon_pairs contains the taxon ID's to compare
taxon_pairs <- combn(taxon_list, m = 2) 

# create any empty data frame to populate with seperability metrics
# each row corresponds to a taxon pair in taxon_pairs,
# while each col corresponds to a seperability metric in this order: 
# B, JM, M, mdif, D, TD 
# (since this is the order generated by spatialEco::separability)
seperability_metrics <- data.frame(matrix(NA, 
                                          nrow = ncol(taxon_pairs), 
                                          ncol = ncol(sep)))
# name the columns accordingly to indicate the seperability metric
colnames(seperability_metrics) <- colnames(sep)


print("Taxon pairs to calculate seperability for: ")
print(taxon_pairs)

for(c in 1:ncol(taxon_pairs)){
  print(c)
  
  # print the taxon ID's of the species currently being compared 
  print(taxon_pairs[1,c])
  print(taxon_pairs[2,c])
  
  # get the mean spectral reflectance for species currently being compared.
  # remove the first column with taxonID, since it's not numeric it will 
  # cause an error in the metric calculations if not removed. 
  refl1 <- mean_reflectance %>% filter(taxonID == taxon_pairs[1,c]) %>%
               select(-taxonID) %>% as.numeric()
  refl2 <- mean_reflectance %>% filter(taxonID == taxon_pairs[2,c]) %>%
               select(-taxonID) %>% as.numeric()
  
  # calculate seperability metrics 
  metrics <- spatialEco::separability(refl1, refl2, plot = TRUE)
  print(metrics)
  
  # store seperability metrics in the data frame
  seperability_metrics[c,] <- metrics
}

# visualize using heat map https://www.r-graph-gallery.com/heatmap/ 
```

```{r species_table}


species_table <- data.table("TaxonID" = c("ABLAL",
                                          "PICOL",
                                          "PIEN",
                                          "PIFL2"),
                            "Scientific name" = c("Abies lasiocarpa",
                                                  "Pinus contorta",
                                                  "Picea engelmannii",
                                                  "Pinus flexilis"),
                            "Common Name" = c("Subalpine fir",
                                              "Lodgepole pine",
                                              "Engelmann spruce",
                                              "Limber pine"),
                            "Number of individual trees" = as.data.frame(table(spectra_all$taxonID))$Freq)


knitr::kable(species_table) %>% kable_styling(bootstrap_options = c("striped", "hover"))
```

```{r rgb_composite}

p <- polygons_in_sp[1]
h5_cropped <- raster::crop(s, p)
dim(h5_cropped)

# get indices of RGB bands within the raster stack 
wl_r <- which.min(abs(wavelengths - 669)) # R 
wl_g <- which.min(abs(wavelengths - 549)) # G 
wl_b <- which.min(abs(wavelengths - 474)) # B 

h5_rgb <- raster::subset(h5_cropped, subset = c(wl_r, wl_g, wl_b)) 


plotRGB(h5_rgb,
        r = 1, g = 2, b = 3,
        stretch = "hist",
        axes = TRUE,
        main="RGB Composite",
        xlab="Easting (m)",
        ylab="Northing (m)",
        cex.main=2)

# write cropped RGB RasterBrick to a tif
writeRaster(h5_rgb,
            paste0(out_dir,"rgb_composite_452000_4432000.tif"), 
            format="GTiff",
            overwrite=TRUE)



```

```{r pixelNumber_comparison_remove_duplicate_spectra}

  # 
  # # see if there is a unique pixelNumber for each row in the extracted spectra df
  # if( length(unique(spectra_write$pixelNumber)) == nrow(spectra_write)) {
  #   print("There is one unique pixel ID for each extracted spectrum")
  # } 
  # 
  # else{
  #   print("There are multiple extracted spectra with the same pixel ID")
  #   
  #   # if the same pixel is extracted more than once (this can happen when polygon
  #   # boundaries are touching or very close to one another), based on multiple
  #   # occurrences of a single "pixelNumber" in the extracted_spectra,
  #   # check the height of the tree. Let the taller tree keep the pixel.
  #   
  #   # loop through all pixelNumber values that appear in the extracted_spectra
  #   # more than once. 
  #   duplicatePixelNumbers <- unique(spectra_write$pixelNumber[duplicated(spectra_write$pixelNumber)])
  #   
  #   for (p in duplicatePixelNumbers){
  #     
  #     print(p)
  #     
  #     spectraComparison <- spectra_write %>% 
  #       select(c("indvdID", "height", "mxCrwnD", "pixelNumber")) %>% 
  #       filter(pixelNumber == p)
  #     
  #     print(spectraComparison)
  #     
  #     # find the maximum height across all rows with the current pixelNumber 
  #     #maxHeight <- max(spectra_write$height[spectra_write$pixelNumber == p])
  #     maxHeight <- max(spectraComparison$height)
  #     
  #     print(paste0("Max height for all rows with current pixelNumber: ", as.character(maxHeight)))
  #     
  #     # if one tree is the tallest, delete the other rows from the extracted spectra. 
  #     if(sum(spectraComparison$height == maxHeight) == 1){
  #       
  #       deleteRows <- which(spectra_write$pixelNumber == p & spectra_write$height != maxHeight) 
  #       
  #       print("Deleting rows: ")
  #       print(deleteRows)
  #       
  #       # delete the rows with duplicated pixelNumber values that are not the tallest trees
  #       spectra_write <- spectra_write %>% filter(!row_number() %in% deleteRows)
  #       
  #     } else{ 
  #       # otherwise, if more than one tree with the current pixelNumber has 
  #       # the maximum height value, see if one has a greater crown diameter 
  #       
  #       maxCrwnD = max(spectraComparison$mxCrwnD)
  #       
  #       print(paste0("Max diam for all rows with current pixelNumber: ", as.character(maxCrwnD)))
  #       
  #       if(sum(spectraComparison$mxCrwnD == maxCrwnD) == 1){
  #         
  #         deleteRows <- which(spectra_write$pixelNumber == p & spectra_write$mxCrwnD != maxCrwnD) 
  #         
  #         print("Deleting rows: ")
  #         print(deleteRows)
  #         
  #         # delete the rows with duplicated pixelNumber values without the largest crown diam
  #         spectra_write <- spectra_write %>% filter(!row_number() %in% deleteRows)
  #         
  #       } else{
  #         # if the duplicate rows have identical height and crown diameter, 
  #         # then just keep the first entry and remove any other duplicates 
  #         print("DUPLICATE ENTRIES HAVE IDENTICAL MAX HEIGHT AND MAX CROWN DIAM.....")
  #         
  #         # keep the first entry that has the max height and max diameter 
  #         keepID <- spectra_write$indvdID[spectra_write$pixelNumber == p &
  #                                           spectra_write$height == maxHeight & 
  #                                           spectra_write$mxCrwnD == maxCrwnD][1]
  #         
  #         # list the other ID's for duplicate pixelNumbers to be deleted 
  #         deleteIDs <- spectraComparison$indvdID[!spectraComparison$indvdID %in% keepID]
  #         
  #         # delete the duplicate entries from the spectra data set 
  #         spectra_write <- spectra_write %>% filter(!indvdID %in% deleteIDs)
  #       }
  #     }
  #   }
  #   
  #   
  #   print("number of unique pixelNumbers in the updated spectra_write data frame: ")
  #   print(length(unique(spectra_write$pixelNumber)))
  #   
  #   print("number of rows in updated spectra_write data frame: ")
  #   print(nrow(spectra_write))
  #   
  # }
  # 

```

