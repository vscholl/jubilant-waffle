---
title: "Hyperspectral Analysis"
author: "Victoria Scholl"
date: "12/27/2018"
output: 
  html_document:
    theme: cosmo
    highlight: zenburn
---

## Introduction

This document outlines the workflow that integrates field-based tree measurements with airborne remote sensing data from the National Ecological Observatory Network (NEON). Using points and polygons generated using the [neon_veg](https://github.com/earthlab/neon-veg) workflow, this R code extracts reflectance values for each tree from hyperspectral image data and performs subsequent spectral analysis. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE,
                      results = 'hide')
```

# Extract reflectance spectra 

## Setup 

First, load the required R packages for this analysis. 

```{r load_packages}
# load necessary R packages 
library(rhdf5)
library(rgdal)
library(raster)
library(ggplot2)
library(tidyr)
library(sf)
library(dplyr)
library(data.table) 
library(knitr) # for nice table formatting
library(kableExtra)
library(RColorBrewer)

# set working directory
setwd("~/github/jubilant-waffle/code/")

# load any local functions in external files 
source("supporting_functions.R")

# define the "bad bands" wavelength ranges in nanometers, where atmospheric 
# absorption creates unreliable reflectance values. 
# --> Instead, read the bad band ranges from metadata?
bad_band_window_1 <- c(1340, 1445)
bad_band_window_2 <- c(1790, 1955)
```

```{r study_area_map}
library(maps)
# plot study area with context on the US map, highlight california 
maps::map('state', fill = TRUE, col = "lightgray", border = "darkgray", lwd = 1)
maps::map(database = "usa", lwd = 1, add = TRUE)
maps::map("state", "colorado", col = "coral1", border = "black", myborder=2,
    lwd = 1, fill = TRUE, add = TRUE)
maps::map.axes(cex = 0.8)
axis.title.x = "Longitude"
#map.text("state","Colo", add=TRUE) # label the state of colorado

# add the NIWO site location
title("Study Area: Niwot Ridge Mountain Research Station (NIWO)\nColorado, NEON Domain 13, Southern Rockies & Colorado Plateau\n")

# add the x, y location of the SJER using the points
points(x = -105.48237, y = 40.05425, pch = 0, col = "black", cex = 1.3, lwd = 1.5)
```

Specify where the hyperspectral data and shapefiles are located. 

* This project is currently structured with "code", "data", and "output" top-level directories.
* Within "data", each NEON site has its own directory named with the site code (such as "NIWO" for Niwot Ridge). 
* The polygon and point shapefiles will be used to clip hyperspectral data to obtain spectral reflectance for each tree location. 

```{r output_directory}
# define the output directory. If it doesn't exist already, create it.
check_create_dir('../output/') # create top level "output" directory
check_create_dir(paste0('../output/', site_code, '/figures')) # folder for plots
out_dir <- paste0('../output/', site_code, '/')
check_create_dir(out_dir) # create output folder for site
```

## Read and pre-process vector data 

Read the shapefiles.
The circular crown poylgons are read in as a SpatialPolygonsDataFrame.
The tree stem locations are read in as a SpatialPointsDataFrame. 
After following the [neon_veg](https://github.com/earthlab/neon-veg) workflow, the *polygons_checked_overlap* shapefile contains polygons that have been checked for overlap with neighboring polygons, preserving those that are most likely visible in the airborne imagery. The *mapped_stems_final* shapefile contains the point locations of the corresponding tree stems. 

```{r read_shapefiles}
# read tree polygons file 
# shapefile sets to test --------------------------------------------------

# shapefiles were generated using the neon_veg workflow
# where each entry (point or polygon) corresponds to a tree in the woody vegetation 
# in-situ field NEON data set.

# directory with shapefiles to test (tree stem locations and crown polygons)
shapefile_dir <- paste0('../data/', site_code, '/shapefiles/')

# define the subdirectory (destination or dsn when reading shapefile)
# and the layer name (the filename before the .shp extension) 
# in a vector for each of the shapefile scenarios. 

# all stem points at NIWO that also have crown diameter measurements. 
# this includes multi-bole entries, which result in duplicated spectra. 
allStems_layer <- c("allStems",
                    "shapefiles_maxDiameter/",
                    "mapped_stems_with_crown_diameter")

# polygons with max crown diameter, one generated for each stem point at NIWO.
# just as for the "allStems" layer above, the shapfile used here
# includes multi-bole entries, since this is how the data come when
# downloaded straight from the data portal. 
allPolygons_maxDiameter_layer <- c("allPolygons_maxDiameter",
                                   "shapefiles_maxDiameter/",
                                   "polygons_all")

# polygons with half max diameter, one generated for each stem point at NIWO. 
allPolygons_halfDiameter_layer <- c("allPolygons_halfDiameter",
                                    "shapefiles_halfDiameter/",
                                    "polygons_all")

# neon_veg workflow stems, corresponding to polygons generated with max diameter
neonvegStems_maxDiameter_layer <- c("neonvegStems_maxDiameter",
                                    "shapefiles_maxDiameter/",
                                    "mapped_stems_final")

# neon_veg workflow polygons generated with half the max diameter  
neonvegPolygons_halfDiameter_layer <- c("neonvegPolygons_halfDiameter",
                                        "shapefiles_halfDiameter/",
                                        "polygons_clipped_overlap")

# neon_veg workflow polygons generated with max diameter 
neonvegPolygons_maxDiameter_layer <- c("neonvegPolygons_maxDiameter",
                                       "shapefiles_maxDiameter/",
                                       "polygons_clipped_overlap")

# create a data frame containing the description, directory, and shapefile name
# for each of the shapefile scenarios to be tested 
shapefileLayerNames <- as.data.frame(rbind(allStems_layer,
                                           allPolygons_halfDiameter_layer,
                                           allPolygons_maxDiameter_layer,
                                           neonvegStems_maxDiameter_layer,
                                           neonvegPolygons_halfDiameter_layer,
                                           neonvegPolygons_maxDiameter_layer),
                                     stringsAsFactors = FALSE) %>% 
          `colnames<-`(c("description", "dsn", "layer")) 
rownames(shapefileLayerNames) <- 1:nrow(shapefileLayerNames)

shapefileLayerNames %>%
  kableExtra::kable() %>%
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover","condensed", 
                                      full_width=F, align = "center"))
```

# Remote Sensing Data

Define the input directories for each of the remote sensing data products.
Within each directory, get a list of all of the corresponding image data files. 

```{r remote_sensing_inputs}

# specify the paths for each data directory
# hyperspectral .h5 and .rds
h5_dir <- paste0('../data/', site_code, '/hyperspectral/') 
# CHM geotiffs 
chm_dir <- paste0('../data/', site_code, '/chm/')      
# slope geotiffs
slope_dir <- paste0('../data/', site_code, '/slope/')   
# aspect geotiffs
aspect_dir <- paste0('../data/', site_code, '/aspect/') 
# rgb image geotiffs
rgb_dir <- paste0('../data/', site_code, '/rgb/')
# vegetation index .tifs 
vegIndices_dir <- paste0('../data/', site_code, '/vegIndices/') 

# list the files in each data directory; filter results based on file type
# hyperspectral data - list the .h5 files 
h5_list <- list.files(path = h5_dir, full.names = TRUE)
h5_list <- h5_list[grepl("*.h5", h5_list)] 
# canopy height model data - list the .tif files 
chm_list <- list.files(path = chm_dir, full.names = TRUE)
chm_list <- chm_list[grepl("*CHM.tif$", chm_list)]
# lidar-derived slope data - list the .tif files 
slope_list <- list.files(path = slope_dir, full.names = TRUE)
slope_list <- slope_list[grepl("*slope.tif$", slope_list)]
# lidar-derived aspect data - list the .tif files
aspect_list <- list.files(path = aspect_dir, full.names = TRUE)
aspect_list <- aspect_list[grepl("*aspect.tif$", aspect_list)]
# digital camera rgb data - list the .tif files 
rgb_list <- list.files(path = rgb_dir, full.names = TRUE)
rgb_list<- rgb_list[grepl("*image.tif$", rgb_list)]
# hyperspectral-derived veg indices - list the subdirectories for each index 
vegIndices_list <- list.dirs(path = vegIndices_dir, full.names = TRUE)
vegIndices_names <- c("ARVI","EVI","NDLI","NDNI","NDVI","PRI","SAVI")


# read wavelengths from text file 
# created in supporting_functions/stack_hyperspectral
wavelengths = as.numeric(unlist(read.table(paste0(out_dir,"wavelengths.txt"),
                                           sep="\n",
                                           skip = 1,
                                           col.names = 'wavelength')))
```

Assemble all of the NEON AOP remote sensing data layers into a giant data cube. A set of spectral and structural features from this data cube will be extracted for each sample (pixel) that intersects with the shapefile entries.  

```{r create_data_cube_extract_features}
# create data cubes with AOP-derived features ---------------------------

start_time <- Sys.time() # start the timer 

# loop through the tiles; build up a data cube for each tile 

for (h5 in h5_list) {
  
  # print current hyperspectral filename 
  print(h5)
  
  # each current hyperspectral tile must be read and stacked into a 
  # georeferenced rasterstack object (so it can be clipped with point / polygon
  # shapefiles). The process of creating a rasterstack takes a while for 
  # each tile, so after creating each rasterstack once, each object gets 
  # written to a file. 
  
  # Build up the rasterstack filename by parsing out the easting/northing
  # coordinates from the current h5 filename.
  
  # parse the UTM easting and northing values from the current h5 filename
  easting <- stringr::str_split(tail(str_split(h5, "/")[[1]],n=1),"_")[[1]][5]
  northing <- stringr::str_split(tail(str_split(h5, "/")[[1]],n=1),"_")[[1]][6]
  # combine them with an underscore; use this to find corresponding tiles 
  # of various remote sensing data
  east_north_string <- paste0(easting,"_",northing)
  
  
  # hyperspectral and lidar features ----------------------------------------
  
  # Build up the h5 rasterstack filename
  rasterstack_filename <- paste0(h5_dir, "rasterstack_",
                                 east_north_string, ".rds")
  
  print(paste("rasterstack filename: ", rasterstack_filename))
  
  # check to see if a .rds file already exists for the current tile
  # within the hyperspectral directory - just HS reflectance bands so far 
  if (file.exists(rasterstack_filename)){
    
    # if it exists, read that instead of re-generating the same rasterstack.
    message("reading rasterstack (already created for current tile)...")
    # restore / read the rasterstack from file
    s <- readRDS(file = rasterstack_filename)
    
  } else{
    
    # if it doesn't exist, generate the rasterstack. 
    message("creating rasterstack for current tile...")
    # create a georeferenced rasterstack using the current hyperspectral tile
    s <- stack_hyperspectral(h5, out_dir)
    # save the rasterstack to file 
    saveRDS(s, file = rasterstack_filename)
  }
  
  # read the corresponding remote sensing data layers for current tile
  print("Reading lidar-derived layers for the training data cube...")
  chm <- raster::raster(grep(east_north_string, chm_list, value=TRUE))
  slope <- raster::raster(grep(east_north_string, slope_list, value=TRUE))
  aspect <- raster::raster(grep(east_north_string, aspect_list, value=TRUE))
  
  # for the vegetation indices, go into the corresponding folder for current tile
  # and get a list of all the vegIndex geotiffs. then read all of those geotiffs 
  # into a single raster stack.
  print("Reading vegetation indices for the training data cube...")
  vegIndices <- raster::stack(list.files(grep(east_north_string, 
                                              vegIndices_list, 
                                              value=TRUE), 
                                         pattern="tif$", full.names=TRUE))
  
  # set the raster name for each layer to be simply the name of the data 
  # (i.e. "aspect") as opposed to the full filename 
  # (i.e. ""NEON_D13_NIWO_DP3_452000_4431000_aspect")
  names(chm) <- "chm"
  names(slope) <- "slope"
  names(aspect) <- "aspect"
  # name each of the vegetation index layers based on the last piece of each 
  # respective filename, e.g. "NDVI" and 
  names(vegIndices) <- sapply(stringr::str_split(names(vegIndices),"_"),tail,1)
  
  # RGB features ------------------------------------------------------------
  
  # The RGB data tile has 10,000 x 10,000 pixels, 10cm spatial resolution. 
  # All other layers tiles have 1,000 x 1,000 pixels, 1 meter spatial resolution. 
  # Aggregate red, green, blue intensity within each coarser grid cell using
  # statistics such as mean and standard deviation. 
  rgb_features_filename <- paste0(rgb_dir, "rgb_features_",
                                  east_north_string, ".rds")
  
  print(paste("rgb_features: ", rgb_features_filename))
  
  # check if a .rds file already exists for the current feature data cube
  if (file.exists(rgb_features_filename)){
    
    # if it exists, read that instead of re-generating the same rasterstack.
    message("reading rgb_features (already created for current tile)...")
    
    # restore / read the rasterstack from file
    rgb_features <- readRDS(file = rgb_features_filename)
    
  } else{
    
    # if it doesn't exist, create the features from the aop data to file 
    message("creating rgb_features for current tile...")
    
    # rgb data has 3 bands. read each one individually 
    rgb_red <- raster::raster(grep(east_north_string, rgb_list, value = TRUE), band = 1) 
    rgb_green <- raster::raster(grep(east_north_string, rgb_list, value = TRUE), band = 2) 
    rgb_blue <- raster::raster(grep(east_north_string, rgb_list, value = TRUE), band = 3) 
    
    # The "fact" parameter of the raster::aggregate function is the number of cells
    # in each direction (horizontal and vertically) to aggregate across.
    # Since the RGB data has a spatial resolution that is 1/10th of the 
    # other data layers (10cm compared to 1m), fact should be 10 to produce 
    # an output raster with 1000 x 1000 pixels. 
    
    # mean intensity per 1m x 1m grid cell 
    rgb_meanR <- raster::aggregate(rgb_red, fact = 10, fun = mean)
    rgb_meanG <- raster::aggregate(rgb_green, fact = 10, fun = mean)
    rgb_meanB <- raster::aggregate(rgb_blue, fact = 10, fun = mean)
    
    # standard deviation of intensity per 1m x 1m grid cell 
    rgb_sdR <- raster::aggregate(rgb_red, fact = 10, fun = sd)
    rgb_sdG <- raster::aggregate(rgb_green, fact = 10, fun = sd)
    rgb_sdB <- raster::aggregate(rgb_blue, fact = 10, fun = sd)
    
    # (mean + SD) gives some idea about relative position on the spectrum
    # and variation rather than just variation (standard deviation on its own)
    rgb_mean_sd_R <- (rgb_meanR + rgb_sdR)
    rgb_mean_sd_G <- (rgb_meanG + rgb_sdG)
    rgb_mean_sd_B <- (rgb_meanB + rgb_sdB)
    
    
    # future work: would be awesome to calculate texture features: 
    # https://cran.r-project.org/web/packages/radiomics/vignettes/TextureAnalysis.html
    
    
    # to confirm the order of the red, green, and blue intensities,
    # stack all 3 bands into a RasterStack and use the plotRGB function.
    # the colors appear natural, so r=1, g=2, b=3
    #rgb_stack <- raster::stack(rgb_red,rgb_green, rgb_blue)
    #raster::plotRGB(rgb_stack, r = 1, g = 2, b = 3)
    
    # set the names of each layer to reflect the metric it contains
    names(rgb_meanR) <- "rgb_meanR" # mean intensity 
    names(rgb_meanG) <- "rgb_meanG"
    names(rgb_meanB) <- "rgb_meanB"
    names(rgb_sdR) <- "rgb_sdR"     # standard deviation of intensity 
    names(rgb_sdG) <- "rgb_sdG"
    names(rgb_sdB) <- "rgb_sdB"
    names(rgb_mean_sd_R) <- "rgb_mean_sd_R" # mean plus standard deviation
    names(rgb_mean_sd_G) <- "rgb_mean_sd_G"
    names(rgb_mean_sd_B) <- "rgb_mean_sd_B"
    
    # stack up all the RGB features
    rgb_features <- raster::stack(rgb_meanR, rgb_meanG, rgb_meanB,
                                  rgb_sdR, rgb_sdG, rgb_sdB,
                                  rgb_mean_sd_R, rgb_mean_sd_G, rgb_mean_sd_B)
    
    # save the stacked features from the aop data to file 
    saveRDS(rgb_features, file = rgb_features_filename)
  }
  
  # Create the pixel number grid as a layer to add to the data cube. 
  # this one keeps track of individual pixel ID's
  # to avoid duplicate spectra being extracted. Basically, assign an integer ID
  # to each pixel in the 1000x1000 raster. This raster needs to have the same 
  # dimensions, extent, crs as the other layers so they can be stacked together. 
  # create a vector of IDs from 1 to the number of pixels in one band (#rows x #cols)
  pixelID <- 1:(nrow(s) * ncol(s))
  # add tile east, north coordinates - how to do this if raster values must be numeric? 
  #pixelID <- paste(pixelID, east_north_string, sep="_") 
  # reshape this 1D vector into a 2D matrix 
  dim(pixelID) <- c(nrow(s),ncol(s))
  # create a raster layer of pixel numbers 
  pixelNumbers <- raster::raster(pixelID, crs = crs(s))
  extent(pixelNumbers) <- extent(s)
  names(pixelNumbers) <- "pixelNumber"
  
  
  # now, all of the hyperspectral data files have been read in for the current
  # tile. add each one to the hyperspectral data stack along with the 
  # layer to keep track pixel number within the tile. 
  stacked_aop_data <- raster::addLayer(s, chm, slope, aspect, vegIndices, 
                                       rgb_features, pixelNumbers)
  print("Stacked AOP data for current tile. ")
  
  # 
  
  
  # clip data cube - extract features ----------------------------------------
  
  # loop through shapefile sets 
  for(i in 1:nrow(shapefileLayerNames)){ 
    print(paste0("Currently extracting features for tree points / polygons in:  ", 
                 shapefileLayerNames$description[i]))
    
    # read the shapefile layer 
    shp <- rgdal::readOGR(dsn = paste0(shapefile_dir,shapefileLayerNames$dsn[i]),
                          layer = shapefileLayerNames$layer[i])
    
    # convert to SF object
    shp_sf <- sf::st_as_sf(shp)
    
    # add columns for the center location of each tree 
    shp_coords <- shp_sf %>% 
      sf::st_centroid() %>%  # get the centroids first for polygon geometries 
      sf::st_coordinates() %>% 
      as.data.frame()
    
    # add new columns for the tree location coordinates 
    shp_sf$X <- shp_coords$X
    shp_sf$Y <- shp_coords$Y
    
    # figure out which trees are within the current tile by comparing each
    # X,Y coordinate to the extent of the current tile 
    trees_in <- shp_sf %>% 
      dplyr::filter(X >= extent(s)[1] & 
                      X < extent(s)[2] & 
                      Y >= extent(s)[3] & 
                      Y  < extent(s)[4])
    
    print(paste0(as.character(nrow(trees_in))," trees in current tile"))
    
    # if no polygons are within the current tile, skip to the next one
    if (nrow(trees_in)==0){
      print("no trees located within current tile... skipping to next shapefile")
      next
    }
    
    # convert from SF obect to Spatial object for clipping
    trees_in_sp <- sf::as_Spatial(trees_in,
                                  IDs = as.character(trees_in$indvdID))
    
    # clip the hyperspectral raster stack with the polygons within current tile.
    # the returned objects are data frames, each row corresponds to a pixel in the
    # hyperspectral imagery. The ID number refers to which tree that the 
    # the pixel belongs to. A large polygon will lead to many extracted pixels
    # (many rows in the output data frame), whereas tree stem points will
    # lead to a single extracted pixel per tree. 
    print("Extracting features for each tree from the data cube... ")
    extracted_spectra <- raster::extract(stacked_aop_data, 
                                         trees_in_sp, 
                                         df = TRUE)
    
    # TO DO: 
    # adjust this extract step to only get pixels WITHIN each tree polygon,
    # also try calculating the percentage that each pixel is within a polygon
    # and keep only pixels with > 50% overlap 
    
    # merge the extracted spectra and other data values with the tree info 
    tree_metadata <- data.frame(trees_in) %>% 
      mutate(ID = 1:nrow(trees_in))
    
    # create a list of increasing integer counts to keep track of how many rows 
    # (pixels or spectra) belong to each tree 
    for (j in unique(extracted_spectra$ID)){
      if(j==1){
        counts = 1:sum(extracted_spectra$ID==j)
      }
      else{
        counts = append(counts, 1:sum(extracted_spectra$ID==j))
      }
    }
    
    # combine the additional data with each spectrum for writing to file.
    # remove the geometry column to avoid issues when writing to csv later 
    spectra_write <- merge(tree_metadata,
                           extracted_spectra,
                           by="ID") %>% 
      mutate(spectra_count = counts)%>% 
      select(ID, spectra_count, everything()) %>% 
      select(-geometry)
    
    # write extracted spectra and other remote sensing data values to file 
    write.csv(spectra_write, 
              file = paste0(out_dir,
                            "extracted_features_",
                            east_north_string, "_",
                            shapefileLayerNames$description[i], ".csv")) 
  }
  
}

end_time <- Sys.time()
elapsed <- end_time - start_time
print("Elapsed time: ")
print(elapsed)
```




For later analysis, these Spatial data frames can be converted to SF objects and additional columns are added to contain the extent information for each tree polygon. 

```{r convert_shapefiles}
# convert polygons and tree locations to SF objects
tree_polygons_sf <- sf::st_as_sf(tree_polygons)
tree_points_sf <- sf::st_as_sf(tree_points) 

# isolate the tree location coordinates 
tree_coords <- tree_points_sf %>% 
  sf::st_coordinates() %>% 
  as.data.frame()

# add new columns for the tree location coordinates 
tree_points_sf$X <- tree_coords$X
tree_points_sf$Y <- tree_coords$Y

# add empty columns for the min and max coordinates for each polygon
tree_polygons_sf$xmin <- NA 
tree_polygons_sf$xmax <- NA 
tree_polygons_sf$ymin <- NA 
tree_polygons_sf$ymax <- NA 

# add the min, max X and Y values to each polygon for filtering 
for (i in 1:nrow(tree_polygons_sf)) {
  tree_polygons_sf$xmin[i] <- as.numeric(sf::st_bbox(tree_polygons_sf$geometry[i])[1])
  tree_polygons_sf$ymin[i] <- as.numeric(sf::st_bbox(tree_polygons_sf$geometry[i])[2])
  tree_polygons_sf$xmax[i] <- as.numeric(sf::st_bbox(tree_polygons_sf$geometry[i])[3])
  tree_polygons_sf$ymax[i] <- as.numeric(sf::st_bbox(tree_polygons_sf$geometry[i])[4])
}

# merge the polygons with tree locations;
# rename the geometry columns to be more descriptive 
tree_polygons_points <- merge(as.data.frame(tree_polygons_sf),
                         as.data.frame(tree_points_sf)
                         [,c("indvdID", "X","Y","geometry")],
                         by="indvdID") %>% 
  dplyr::rename(geometry.polygon = geometry.x, 
                geometry.point = geometry.y)
```

## Read and pre-process raster data 

The hyperspectral data is available in 1km x 1km square tiles.

Read the first tile metadata and reflectance data. 

```{r read_hyperspectral}
# get the names of all HDF5 files to iterate through
h5_list <- list.files(path = h5_dir, full.names = TRUE)
h5_list <- h5_list[grepl("*.h5", h5_list)]

# select first HDF5 file 
h5 <- h5_list[1]
print(h5)

# list the contents of HDF5 file
h5_struct <- rhdf5::h5ls(h5, all=T)

# construct the string using "/Reflectance/Metadata/Coordinate_System",
# without explicitly using a site code 
crs_tag <- h5_struct$group[grepl("/Reflectance/Metadata/Coordinate_System", 
                                 h5_struct$group)][1] 

# read coordinate reference system data
crs_info <- rhdf5::h5read(h5, crs_tag)

# convert "UTM" to lowercase "utm" for proper usage later
crs_info$Proj4 <- CRS(chartr("UTM", "utm", crs_info$Proj4))

# get attributes for the Reflectance dataset.
# construct the string using "/Reflectance/Reflectance_Data"" 
refl_tag <- paste0(h5_struct$group[grepl("/Reflectance", 
                                         h5_struct$group)][1],
                   "/Reflectance_Data")

# read the reflectance metadata
refl_info <- rhdf5::h5readAttributes(h5,refl_tag)

# get the dimensions of the reflectance data
n_rows <- refl_info$Dimensions[1]
n_cols <- refl_info$Dimensions[2]
n_bands <- refl_info$Dimensions[3]

# print dimensions 
print(paste0("# Rows: ", as.character(n_rows)))
print(paste0("# Columns: ", as.character(n_cols)))
print(paste0("# Bands: ", as.character(n_bands)))

# read the wavelengths of the hyperspectral image bands
wavelength_tag <- paste0(h5_struct$group[grepl("/Reflectance/Metadata/Spectral_Data", 
                                               h5_struct$group)][1],
                         "/Wavelength")
wavelengths <- rhdf5::h5read(h5,
                             wavelength_tag)

# define spatial extent: extract resolution and origin coordinates
map_info <- unlist(strsplit(crs_info$Map_Info, 
                            split = ", "))
res_x <- as.numeric(map_info[6])
res_y <- as.numeric(map_info[7])
x_min <- as.numeric(map_info[4])
y_max <- as.numeric(map_info[5])

# calculate the maximum X and minimum Y values 
x_max <- (x_min + (n_cols * res_x))
y_min <- (y_max - (n_rows * res_y))
tile_extent <- raster::extent(x_min, x_max, y_min, y_max)

# read reflectance data for all bands
refl <- rhdf5::h5read(h5, refl_tag,
                      index = list(1:n_bands, 1:n_cols, 1:n_rows))

# view and apply scale factor to convert integer values to reflectance [0,1]
# and data ignore value
scale_factor <- refl_info$Scale_Factor
data_ignore <- refl_info$Data_Ignore_Value
refl[refl == data_ignore] <- NA 
refl_scaled <- refl / scale_factor
```

## Extract reflectance spectra for each tree from hyperspectral imagery 

As this [Earth Lab tutorial](https://www.earthdatascience.org/courses/earth-analytics/lidar-raster-data-r/crop-raster-data-in-r/) describes, there is an **extract** function within the **raster** R package. It requires raster and and vector objects. 

As for the vector layers, let's figure out which trees are within the current tile and convert their corresponding points and polygons from SF objects to SpatialPoints and SpatialPolygons forms. 

```{r polygons_in_tile}
# figure out which trees are within the current tile 
polygons_in <- tree_polygons_points %>% 
  dplyr::filter(xmin >= tile_extent@xmin & 
                xmax < tile_extent@xmax & 
                ymin >= tile_extent@ymin & 
                ymax < tile_extent@ymax)

print(paste0(as.character(nrow(polygons_in))," polygons in current tile"))

# if no polygons are within the current tile, skip to the next one
if (nrow(polygons_in)==0){
  print("no trees located within current tile... skipping to next tile")
  next
}

# convert from SF obect to SpatialPolygons object for clipping
polygons_in_sp <- sf::as_Spatial(polygons_in$geometry.polygon,
                                 IDs = as.character(polygons_in$indvdID))
points_in_sp <- sf::as_Spatial(polygons_in$geometry.point,
                                 IDs = as.character(polygons_in$indvdID))

```

Let's stack up all of the hyperspectral bands into a RasterStack (a collection of Raster layers with the same spatial resolution and extent) as the raster input to this function. 

```{r create_hyperspectral_rasterstack}

# create georeferenced raster using band 1 
r1 <- (refl_scaled[1,,]) # convert first band to matrix
r1 <- raster::raster(r1, crs = crs_info$Proj4)
extent(r1) <- tile_extent

# start the raster stack with first band 
s <- raster::stack(r1)

# loop through bands and create a giant rasterstack with 426 (n_bands) bands
for(b in 2:n_bands){
  print(b)
  
  # create raster with current band
  r <- (refl_scaled[b,,]) # convert to matrix
  r <- raster::raster(r, crs = crs_info$Proj4)
  extent(r) <- tile_extent
  
  # add additional band to the stack with the addLayer function
  s <- raster::addLayer(s, r)
  
}

# adjust the names for each layer in raster stack to correspond to wavelength
names(s) <- round(wavelengths)
```

Let's clip the scaled hyperspectral reflectance rasterstack with the tree polygons to extract reflectance curves for each tree stem point, and within each polygon area. 

```{r extract_rasterstack_spectra}
# clip the hyperspectral raster stack with the polygons within current tile.
# the returned objects are data frames, each row corresponds to a pixel in the
# hyperspectral imagery. The ID number refers to which polygon or point that 
# the pixel belongs to. A large polygon will lead to many extracted pixels
# (many rows in the output data frame)
extracted_point_spectra <- raster::extract(s, points_in_sp, df = TRUE)
extracted_polygon_spectra <- raster::extract(s, polygons_in_sp, df = TRUE)
```

In the resulting data frames, each row contains a single reflectance spectrum, corresponding to a single pixel location (x,y) in the hyperspectral imagery. 

* In the **extracted_point_spectra**, there is one row per tree stem.
* In the **extracted_polygon_spectra**, there are multiple rows per tree polygon. A larger polygon will intersect with more pixels, producing more rows for trees with large crowns in this output data frame. 
* The "ID" column contains an integer to identify which of the trees within the tile that the spectra belong to. 

For instance, let's take a look at the first 12 rows of the extracted_point_spectra. Thee first 5 columns are displayed here, which contain "ID" values and the first few reflectance values for low wavelengths around 380nm. Notice that the ID column contains values that increase monotonically with rows for the extracted point spectra, since each tree stem point intersects with a single pixel in the hyperspectral imagery. 

```{r head_point_spectra, results = TRUE}
head(extracted_point_spectra[,1:5], n = 12)
```

The first 12 rows of the extracted_polygon_spectra look different (specifically, the **ID** column). Rows 1 through 10 have an ID of 1. This means that tree 1 in the SpatialPolygons object intersected with 10 pixels in the hyperspectral imagery, so there are 10 spectra available for analysis. Tree 2 in the SpatialPolygons object intersects with more than 1 pixel too. We can see the beginning of those spectra in rows 11 and 12 below. 

```{r head_polygon_spectra, results = TRUE}
head(extracted_polygon_spectra[,1:5], n = 12)
```


Write the spectral reflectance data to file for each tree. Combine each spectrum with more information about each corresponding tree (including the individual ID, species, and height).
For the extracted spectra with more than one row per tree, adjust the "ID" column to reflect how many spectra correspond to each tree. 

```{r combine_metadata_write_spectra, results = TRUE}

# create polygon metadata data frame 
polygon_metadata <- data.frame(individualID = polygons_in$indvdID,
                              scientificName = polygons_in$scntfcN,
                              taxonID = polygons_in$taxonID,
                              maxCrownDiameter = polygons_in$crownDm,
                              height = polygons_in$height,
                              X = polygons_in$X,
                              Y = polygons_in$Y,
                              # create ID column to pair the polygon metadata with  spectra
                              ID =  1:nrow(polygons_in))

# create a list of increasing integer counts to keep track of how many rows 
# (pixels or spectra) belong to each tree 
for (i in unique(extracted_polygon_spectra$ID)){
  if(i==1){
    counts = 1:sum(extracted_polygon_spectra$ID==i)
  }
  else{
    counts = append(counts, 1:sum(extracted_polygon_spectra$ID==i))
  }
}

# combine the additional data with each spectrum for writing to file
spectra_write <- merge(polygon_metadata,
                       as.data.frame(extracted_polygon_spectra),
                       by="ID") %>% 
  mutate(spectra_count = counts)%>% 
  select(ID, spectra_count, everything())
  
# take a look at the first rows of the spectra data to write 
head(spectra_write[,1:10] %>% select(-c(scientificName,X,Y)))


# write the spectral data to file for future analysis 
write.csv(spectra_write, file = paste0(out_dir,
                                       "spectral_reflectance_",
                                        as.character(tile_extent@xmin),"_",
                                        as.character(tile_extent@ymin),".csv")) 
  
```

The accompanying *hyperspectral_analysis.R* script loops through all of the HDF5 files and extracts spectra using the steps described above. The spectra are written to separate .csv files for each tile, then combined into a single .csv tile for subsequent analysis. 

The code below reads the .csv file with all spectra for different types of shapefiles.

(1) All of the spectra extracted at **each stem location** (in theory, the central pixel per tree crown). *One pixel extracted per tree.*

(2) All of the spectra ectracted within the **"checked_overlap" polygons** generated by the neon_veg workflow. *The number of spectra per tree is based on the size/location of each polygon and how many pixels it intersects with.* Since these polygons may be clipped based on their proximity and height compared to neighboring trees, there will be fewer polygons for this scenario compared to the next. 

(3) All of the spectra extracted using the **"buffer" argument** in the raster::extract function. The buffer size was set based on the max_diameter of each tree crown. *The number of spectra per tree is based on the size/location of each polygon and how many pixels it intersects with.* 

```{r read_all_spectra}
# read all of the reflectance spectra extracted for all trees in current site.
# remove the column labeled "X.1", which just has row numbers. 


# (1) stem point locations 
out_description <- "stem_points" # stem point locations 
spectra_all_points_filename <- paste0(out_dir, 
                                             site_code,
                                             "_spectral_reflectance_ALL_",
                                              out_description, ".csv")
spectra_all_points <- as.data.frame(read.csv(spectra_all_points_filename)) %>% 
                  select(-X.1)


# (2) checked_overlap polygons
out_description <- "polygons_checked_overlap_max_diameter" # checked_overlap polygons
spectra_all_overlapPolygons_filename <- paste0(out_dir, 
                                             site_code,
                                             "_spectral_reflectance_ALL_",
                                              out_description, ".csv")
spectra_all_overlapPolygons <- as.data.frame(read.csv(spectra_all_overlapPolygons_filename)) %>% 
                  select(-X.1)


# (3) buffer_max_diameter
out_description <- "buffer_max_diameter" # buffer of (maxCrownDiameter / 2)
spectra_all_bufferPolygons_filename <- paste0(out_dir, 
                                             site_code,
                                             "_spectral_reflectance_ALL_",
                                              out_description, ".csv")
spectra_all_bufferPolygons <- as.data.frame(read.csv(spectra_all_bufferPolygons_filename)) %>% 
                  select(-X.1)




spectra_all <- spectra_all_points
spectra_all_overlapPolygons <- spectra_all_overlapPolygons
# filter the spectra to reduce the number of them for quick visualization 
# figure out how to extract spectra for the center pixels most efficiently, make a 
# function out of hyperspectral_analysis.R? 
#set.seed(12)
#spectra_all <- spectra_all[sample(nrow(spectra_all), size = 100),]
#spectra_all <- spectra_write # use the single tile spectra from above for quick viz 
```



# Spectral Analysis

## Plot reflectance spectra

Plot the reflectance spectra as a function of wavelength. First, let's see them all on a single graph, colored by species.

For reference, here is a table detailing the scientific names, common names, taxon ID values, and number of tree stems present in the data set for each of the four species present at the Niwot Ridge site: 

```{r species_table, echo=FALSE, results=TRUE}
library(knitr)
library(kableExtra)
species_table <- data.table("TaxonID" = c("ABLAL",
                                           "PICOL",
                                           "PIEN",
                                           "PIFL2"),
                            "Scientific name" = c("Abies lasiocarpa",
                                                  "Pinus contorta",
                                                  "Picea engelmannii",
                                                  "Pinus flexilis"),
                            "Common Name" = c("Subalpine fir",
                                              "Lodgepole pine",
                                              "Engelmann spruce",
                                              "Limber pine"),
                            "Number of stems" = as.data.frame(table(tree_points$taxonID))$Freq)

knitr::kable(species_table) %>% kable_styling(bootstrap_options = c("striped", "hover"))
```


```{r plot_spectra}

# keep just the reflectance values along with individual ID and species
# for the first tree
spectra_1 <- spectra_all[1,] %>% 
                dplyr::select(-c(X,Y,ID))

# organize the data into a data frame where the first column contains
# the individualID, second column contains scientific name, 
# followed by additional tree metadata and finally
# reflectance per wavelength.  
spectra_plot <- tidyr::gather(spectra_1,
                              key = wavelength,
                              value = "reflectance",
                              -individualID,
                              -scientificName,
                              -taxonID,
                              -maxCrownDiameter,
                              -height,
                              -spectra_count)
# add the actual wavelenth values into the wavelengths column
spectra_plot$wavelength <- wavelengths

# loop through the remaining spectra and repeat 
for (i in 2:nrow(spectra_all)){
  spectra_current <- spectra_all[i,] %>% 
                        dplyr::select(-c(X,Y,ID))
  spectra_current <- tidyr::gather(spectra_current,
                                key = wavelength,
                                value = "reflectance",
                                -individualID,
                                -scientificName,
                                -taxonID,
                                -maxCrownDiameter,
                                -height,
                                -spectra_count)
  spectra_current$wavelength <- wavelengths
  
  spectra_plot <- rbind(spectra_plot, spectra_current)
  
}

# remove the first reflectance value 
spectra_plot <- spectra_plot[spectra_plot$wavelength > 385,]

# remove the bad bands 
remove_bands <- wavelengths[(wavelengths > bad_band_window_1[1] & 
                            wavelengths < bad_band_window_1[2]) | 
                           (wavelengths > bad_band_window_2[1] & 
                            wavelengths < bad_band_window_2[2])]

spectra_plot$reflectance[spectra_plot$wavelength %in% remove_bands] <- NA
```

```{r point_spectra_single_plot, results=TRUE}
# plot all spectra on single plot 
# adjust line width and alpha for better visibility with many curves
ggplot(data = spectra_plot, 
       aes(x = wavelength, 
           y = reflectance, 
           colour = taxonID)) +
  geom_line(aes(group = individualID), size = 0.5, alpha = 0.7) + 
  labs(x = "wavelength (nm)", 
       color = "species") + 
  ggtitle("Hyperspectral reflectance extracted per pixel") +
          scale_color_manual(values = c("#d7191c", "#fdae61", "#abdda4", "#2b83ba")
  )
```

We can also plot the reflectance spectra on four separate plots, one per species. 

```{r point_spectra_multi_plot, results=TRUE}
# Use facet_grid for a separate plot per species 
ggplot(data = spectra_plot, 
       aes(x = wavelength, 
           y = reflectance, 
           colour = taxonID)) +
  geom_line(aes(group = individualID), alpha = 0.5) + 
  facet_wrap(. ~ taxonID, ncol = 2) + 
  labs(x = "wavelength (nm)", color = "species") + 
  ggtitle("Hyperspectral reflectance extracted per pixel") + 
  scale_color_manual(values = c("#d7191c", "#fdae61", "#abdda4", "#2b83ba"))
```

We can also plot all of the spectra for a single species in a single figure:

```{r results=TRUE}
# keep only the Engelmann spruce trees.
# give each curve its own color to help visualize some of the different shapes
ggplot(data = spectra_plot %>% filter(taxonID == "PIEN"), 
       aes(x = wavelength, 
           y = reflectance, 
           colour = individualID)) +
  geom_line(aes(group = individualID), size = 0.5, alpha = 0.5) + 
  labs(x = "wavelength (nm)") + 
  ggtitle("Hyperspectral reflectance curves, Engelmann Spruce") +
  theme(legend.position="none") # remove legend 
```



To assess the difference between a single stem location and a collection of pixels within a tree crown polygon, let's plot a single reflectance spectrum compared to a series of them. 

```{r plot_compare_point_polygon}
# all reflectance spectra for a tree polygon
j <- 25 # select an individual tree 
spectra_tree <- spectra_plot %>% 
              filter(individualID==as.character(unique(spectra_plot$individualID)[j])) 

# single reflectance spectrum for a tree stem point
spectrum_tree <- spectra_tree %>% 
                  filter(spectra_count == spectra_tree$spectra_count[1])

# plot reflectance spectrum for a single tree stem location pixel 
ggplot(data = spectrum_tree, 
       aes(x = wavelength, 
           y = reflectance, 
           colour = taxonID)) +
  geom_line(aes(group = individualID), size = 0.5, alpha = 1) + 
  labs(x = "wavelength (nm)") + 
  ggtitle(paste0("Hyperspectral reflectance for a single pixel, tree ",
                 as.character(unique(spectra_plot$individualID)[j]))) +
          scale_color_manual(values = c("#1c9099")
  )



# for this plot, use the polygon spectra
spectra_subset_overlapPolygons <- spectra_all_overlapPolygons %>% 
  filter(individualID==as.character(unique(spectra_plot$individualID)[j]))

spectra_1_overlapPolygons <- spectra_subset_overlapPolygons[1,] %>% 
                dplyr::select(-c(X,Y,ID))

spectra_plot_overlapPolygons <- tidyr::gather(spectra_1_overlapPolygons,
                              key = wavelength,
                              value = "reflectance",
                              -individualID,
                              -scientificName,
                              -taxonID,
                              -maxCrownDiameter,
                              -height,
                              -spectra_count)

spectra_plot_overlapPolygons$wavelength <- wavelengths

# loop through the remaining spectra and repeat 
for (i in 2:nrow(spectra_subset_overlapPolygons)){
  spectra_current <- spectra_subset_overlapPolygons[i,] %>% 
                        dplyr::select(-c(X,Y,ID))
  spectra_current <- tidyr::gather(spectra_current,
                                key = wavelength,
                                value = "reflectance",
                                -individualID,
                                -scientificName,
                                -taxonID,
                                -maxCrownDiameter,
                                -height,
                                -spectra_count)
  spectra_current$wavelength <- wavelengths
  
  spectra_plot_overlapPolygons <- rbind(spectra_plot_overlapPolygons, 
                                        spectra_current)
  
}

# remove the first reflectance value 
spectra_plot_overlapPolygons <- spectra_plot_overlapPolygons[spectra_plot_overlapPolygons$wavelength > 385,]

# remove the bad bands 
spectra_plot_overlapPolygons$reflectance[spectra_plot_overlapPolygons$wavelength %in% remove_bands] <- NA


# plot containing multiple pixels within a tree polygon
ggplot(data = spectra_plot_overlapPolygons, 
       aes(x = wavelength, 
           y = reflectance,
           colour = as.factor(spectra_count))) +
  geom_line(aes(group = spectra_count), size = 0.5, alpha = 1) + 
  labs(x = "wavelength (nm)", color = "spectra count") + 
  ggtitle(paste0("Hyperspectral reflectance for multiple pixels intersecting with polygon, \n tree ",
          as.character(unique(spectra_plot$individualID)[j]))) +
  scale_color_manual(values = brewer.pal(length(unique(spectra_plot_overlapPolygons$spectra_count)),
                                         "Set1"))
```



To visualize the variation of spectra per species, let's add shadded regions to capture the minimum and maximum reflectance per wavelength and see if there are any notable divergences between species. 

```{r ribbon_plot, results=TRUE}

# calculate mean reflectance per species
mean_reflectance <- stats::aggregate(spectra_all[,10:ncol(spectra_all)], 
                                     by = list(taxonID = spectra_all$taxonID),
                                     FUN = mean) 
min_reflectance <- stats::aggregate(spectra_all[,10:ncol(spectra_all)], 
                                     by = list(taxonID = spectra_all$taxonID),
                                     FUN = min) 
max_reflectance <- stats::aggregate(spectra_all[,10:ncol(spectra_all)], 
                                     by = list(taxonID = spectra_all$taxonID),
                                     FUN = max) 

# create a LUT that matches actual wavelength values with the column names,
# X followed by the rounded wavelength values. 
wavelength_lut <- data.frame(wavelength = wavelengths,
                             xwavelength = paste0("X",as.character(round(wavelengths))),
                             stringsAsFactors = FALSE)

# use the gather function makes wide data longer:
# https://uc-r.github.io/tidyr 
# so the reflectance data can easily be grouped by species, 
# and the mean/min/max reflectance values can be selected for a ribbon plot. 
mean_refl_tidy <- tidyr::gather(mean_reflectance,
                                key = xwavelength,
                                value = "mean_reflectance",
                                X381:X2510) %>%
  dplyr::left_join(wavelength_lut, by="xwavelength") 

# add on the min reflectance column with the same format 
max_refl_tidy <- tidyr::gather(max_reflectance,
                                key = xwavelength,
                                value = "max_reflectance",
                                X381:X2510)

min_refl_tidy <- tidyr::gather(min_reflectance,
                                key = xwavelength,
                                value = "min_reflectance",
                                X381:X2510)

# combine the mean, min, man reflectance data into one long data frame
refl_tidy <- merge.data.frame(mean_refl_tidy,
                              max_refl_tidy) %>% 
  merge.data.frame(min_refl_tidy) %>% 
  select(-xwavelength) %>%          # remove the Xwavelength values 
  select(wavelength, everything())  # reorder to wavelength column is first



# remove the first reflectance value 
refl_tidy <- refl_tidy[refl_tidy$wavelength > 385,]

# remove the bad bands 
refl_tidy$mean_reflectance[refl_tidy$wavelength %in% remove_bands] <- NA
refl_tidy$max_reflectance[refl_tidy$wavelength %in% remove_bands] <- NA
refl_tidy$min_reflectance[refl_tidy$wavelength %in% remove_bands] <- NA


# specify the colors for the reflectance curves & shading around them 
shading_colors <- c("#d7191c", "#fdae61", "#abdda4", "#2b83ba")
species <- sort(unique(spectra_all$taxonID)) #alphabetical so colors match plot above
shading_alpha <- 0.4

# generate the ribbon plot
ggplot(refl_tidy, 
       aes(x = wavelength, y = mean_reflectance, color = taxonID)) + 
      
      # shaded ribbon from min to max for each species
      # can't get the shading colors to match the lines
      #geom_ribbon(aes(ymin = min_reflectance,
      #                ymax = max_reflectance,
      #                alpha = 0.1,
      #                fill = taxonID)) + 
  
      # ABLAL
      geom_ribbon(data = refl_tidy[refl_tidy$taxonID == species[1], ],
                    aes(ymin = min_reflectance, ymax = max_reflectance),
                  colour=NA,
                  alpha = shading_alpha,
                  fill = shading_colors[1],
                  show.legend = F) + 
  
      # PICOL
      geom_ribbon(data = refl_tidy[refl_tidy$taxonID == species[2], ],
                    aes(ymin = min_reflectance, ymax = max_reflectance),
                  colour=NA,
                  alpha = shading_alpha,
                  fill = shading_colors[2],
                  show.legend = F) + 

      # PIEN
      geom_ribbon(data = refl_tidy[refl_tidy$taxonID == species[3], ],
                    aes(ymin = min_reflectance, ymax = max_reflectance),
                  colour=NA,
                  alpha = shading_alpha,
                  fill = shading_colors[3],
                  show.legend = F) + 
  
      # PIFL2
      geom_ribbon(data = refl_tidy[refl_tidy$taxonID == species[4], ],
                    aes(ymin = min_reflectance, ymax = max_reflectance),
                  colour=NA,
                  alpha = shading_alpha,
                  fill = shading_colors[4],
                  show.legend = F) + 

  
      # mean reflectance line
      # placing this after the ribbon shading so the mean curves are visible
      geom_line(size = 0.5, alpha = 1) + 
  
      scale_color_manual(values = shading_colors) + 
  
      # hide the "alpha" legend
      guides(alpha=FALSE) + 

      # label X and Y axes 
      labs(x = "wavelength (nm)", y = "reflectance") + 
  
      # main plot title  
      ggtitle(paste0("Mean Hyperspectral reflectance per species \n",
                    "(shading shows minimum and maximum refl range per wavelength)")) 

ggsave(paste0(out_dir,"/figures/","ribbon_plot.png"), width = 10, height = 6)

```

## Spectral seperability analysis

The [separability](https://www.rdocumentation.org/packages/spatialEco/versions/1.1-0/topics/separability) function within the SpatialEco R package calculates a variety of two-class sample separability metrics:

* *B* Bhattacharryya distance statistic (Bhattacharyya 1943; Harold 2003) - Measures the similarity of two discrete or continuous probability distributions.

* *JM* Jeffries-Matusita distance statistic  (Bruzzone et al., 2005; Swain et al., 1971) - The J-M distance is a function of separability that directly relates to the probability of how good a resultant classification will be. 

* *M* M-Statistic (Kaufman & Remer 1994) - This is a measure of the difference of the distributional peaks. A large M-statistic indicates good separation between the two classes as within-class variance is minimized and between-class variance maximized (M <1 poor, M >1 good).

* *D* Divergence index and *TD* Transformed Divergence index (Du et al., 2004) - Maximum likelihood approach. Transformed divergence gives an exponentially decreasing weight to increasing distances between the classes.




```{r results = TRUE}
# install.packages("spatialEco")
# library(spatialEco)
x <- as.numeric(mean_reflectance[1,2:length(wavelengths)]) # first row, ABLAB
y <- as.numeric(mean_reflectance[2,2:length(wavelengths)]) # second row, PICOL
sep <- spatialEco::separability(x, y, plot = TRUE)
  
# calculate seperability between each pair of species, for each polygon size 


# visualize using heat map https://www.r-graph-gallery.com/heatmap/ 

```

```{r seperability}
# Spectral seperability  --------------------------------------------------

# The [separability](https://www.rdocumentation.org/packages/spatialEco/versions/1.1-0/topics/separability) 
# function within the SpatialEco R package calculates a variety of two-class 
# sample separability metrics:
  
#  * *B* Bhattacharryya distance statistic (Bhattacharyya 1943; Harold 2003) - 
#        Measures the similarity of two discrete or continuous probability distributions.
#   * *JM* Jeffries-Matusita distance statistic (Bruzzone et al., 2005; Swain et al., 1971) - 
#          The J-M distance is a function of separability that directly relates to the 
#          probability of how good a resultant classification will be. 
#   * *M* M-Statistic (Kaufman & Remer 1994) - This is a measure of the difference of 
#          the distributional peaks. A large M-statistic indicates good separation 
#          between the two classes as within-class variance is minimized and 
#          between-class variance maximized (M <1 poor, M >1 good).
#   * *D* Divergence index and *TD* Transformed Divergence index (Du et al., 2004) - 
#         Maximum likelihood approach. Transformed divergence gives an exponentially 
#         decreasing weight to increasing distances between the classes.

# install.packages("spatialEco")
library(spatialEco)
x <- as.numeric(mean_reflectance[1,2:length(wavelengths)]) # first row, ABLAB
y <- as.numeric(mean_reflectance[2,2:length(wavelengths)]) # second row, PICOL
sep <- spatialEco::separability(x, y, plot = TRUE)
print(sep)

# calculate seperability between each pair of species, for each polygon size 


# create a list of each pair of species to compare seperability 
taxon_list <- as.character(mean_reflectance$taxonID)
# each column in taxon_pairs contains the taxon ID's to compare
taxon_pairs <- combn(taxon_list, m = 2) 

# create any empty data frame to populate with seperability metrics
# each row corresponds to a taxon pair in taxon_pairs,
# while each col corresponds to a seperability metric in this order: 
# B, JM, M, mdif, D, TD 
# (since this is the order generated by spatialEco::separability)
seperability_metrics <- data.frame(matrix(NA, 
                                          nrow = ncol(taxon_pairs), 
                                          ncol = ncol(sep)))
# name the columns accordingly to indicate the seperability metric
colnames(seperability_metrics) <- colnames(sep)


print("Taxon pairs to calculate seperability for: ")
print(taxon_pairs)

for(c in 1:ncol(taxon_pairs)){
  print(c)
  
  # print the taxon ID's of the species currently being compared 
  print(taxon_pairs[1,c])
  print(taxon_pairs[2,c])
  
  # get the mean spectral reflectance for species currently being compared.
  # remove the first column with taxonID, since it's not numeric it will 
  # cause an error in the metric calculations if not removed. 
  refl1 <- mean_reflectance %>% filter(taxonID == taxon_pairs[1,c]) %>%
               select(-taxonID) %>% as.numeric()
  refl2 <- mean_reflectance %>% filter(taxonID == taxon_pairs[2,c]) %>%
               select(-taxonID) %>% as.numeric()
  
  # calculate seperability metrics 
  metrics <- spatialEco::separability(refl1, refl2, plot = TRUE)
  print(metrics)
  
  # store seperability metrics in the data frame
  seperability_metrics[c,] <- metrics
}

# visualize using heat map https://www.r-graph-gallery.com/heatmap/ 
```

```{r species_table}


species_table <- data.table("TaxonID" = c("ABLAL",
                                          "PICOL",
                                          "PIEN",
                                          "PIFL2"),
                            "Scientific name" = c("Abies lasiocarpa",
                                                  "Pinus contorta",
                                                  "Picea engelmannii",
                                                  "Pinus flexilis"),
                            "Common Name" = c("Subalpine fir",
                                              "Lodgepole pine",
                                              "Engelmann spruce",
                                              "Limber pine"),
                            "Number of individual trees" = as.data.frame(table(spectra_all$taxonID))$Freq)


knitr::kable(species_table) %>% kable_styling(bootstrap_options = c("striped", "hover"))
```

```{r rgb_composite}

p <- polygons_in_sp[1]
h5_cropped <- raster::crop(s, p)
dim(h5_cropped)

# get indices of RGB bands within the raster stack 
wl_r <- which.min(abs(wavelengths - 669)) # R 
wl_g <- which.min(abs(wavelengths - 549)) # G 
wl_b <- which.min(abs(wavelengths - 474)) # B 

h5_rgb <- raster::subset(h5_cropped, subset = c(wl_r, wl_g, wl_b)) 


plotRGB(raster::t(h5_rgb),
        r = 1, g = 2, b = 3,
        stretch = "hist",
        axes = TRUE,
        main="RGB Composite",
        xlab="Easting (m)",
        ylab="Northing (m)",
        cex.main=2)

# write cropped RGB RasterBrick to a tif
writeRaster(raster::t(h5_rgb),
            paste0(out_dir,"rgb_composite_452000_4432000.tif"), 
            format="GTiff",
            overwrite=TRUE)



```

```{r pixelNumber_comparison_remove_duplicate_spectra}

  # 
  # # see if there is a unique pixelNumber for each row in the extracted spectra df
  # if( length(unique(spectra_write$pixelNumber)) == nrow(spectra_write)) {
  #   print("There is one unique pixel ID for each extracted spectrum")
  # } 
  # 
  # else{
  #   print("There are multiple extracted spectra with the same pixel ID")
  #   
  #   # if the same pixel is extracted more than once (this can happen when polygon
  #   # boundaries are touching or very close to one another), based on multiple
  #   # occurrences of a single "pixelNumber" in the extracted_spectra,
  #   # check the height of the tree. Let the taller tree keep the pixel.
  #   
  #   # loop through all pixelNumber values that appear in the extracted_spectra
  #   # more than once. 
  #   duplicatePixelNumbers <- unique(spectra_write$pixelNumber[duplicated(spectra_write$pixelNumber)])
  #   
  #   for (p in duplicatePixelNumbers){
  #     
  #     print(p)
  #     
  #     spectraComparison <- spectra_write %>% 
  #       select(c("indvdID", "height", "mxCrwnD", "pixelNumber")) %>% 
  #       filter(pixelNumber == p)
  #     
  #     print(spectraComparison)
  #     
  #     # find the maximum height across all rows with the current pixelNumber 
  #     #maxHeight <- max(spectra_write$height[spectra_write$pixelNumber == p])
  #     maxHeight <- max(spectraComparison$height)
  #     
  #     print(paste0("Max height for all rows with current pixelNumber: ", as.character(maxHeight)))
  #     
  #     # if one tree is the tallest, delete the other rows from the extracted spectra. 
  #     if(sum(spectraComparison$height == maxHeight) == 1){
  #       
  #       deleteRows <- which(spectra_write$pixelNumber == p & spectra_write$height != maxHeight) 
  #       
  #       print("Deleting rows: ")
  #       print(deleteRows)
  #       
  #       # delete the rows with duplicated pixelNumber values that are not the tallest trees
  #       spectra_write <- spectra_write %>% filter(!row_number() %in% deleteRows)
  #       
  #     } else{ 
  #       # otherwise, if more than one tree with the current pixelNumber has 
  #       # the maximum height value, see if one has a greater crown diameter 
  #       
  #       maxCrwnD = max(spectraComparison$mxCrwnD)
  #       
  #       print(paste0("Max diam for all rows with current pixelNumber: ", as.character(maxCrwnD)))
  #       
  #       if(sum(spectraComparison$mxCrwnD == maxCrwnD) == 1){
  #         
  #         deleteRows <- which(spectra_write$pixelNumber == p & spectra_write$mxCrwnD != maxCrwnD) 
  #         
  #         print("Deleting rows: ")
  #         print(deleteRows)
  #         
  #         # delete the rows with duplicated pixelNumber values without the largest crown diam
  #         spectra_write <- spectra_write %>% filter(!row_number() %in% deleteRows)
  #         
  #       } else{
  #         # if the duplicate rows have identical height and crown diameter, 
  #         # then just keep the first entry and remove any other duplicates 
  #         print("DUPLICATE ENTRIES HAVE IDENTICAL MAX HEIGHT AND MAX CROWN DIAM.....")
  #         
  #         # keep the first entry that has the max height and max diameter 
  #         keepID <- spectra_write$indvdID[spectra_write$pixelNumber == p &
  #                                           spectra_write$height == maxHeight & 
  #                                           spectra_write$mxCrwnD == maxCrwnD][1]
  #         
  #         # list the other ID's for duplicate pixelNumbers to be deleted 
  #         deleteIDs <- spectraComparison$indvdID[!spectraComparison$indvdID %in% keepID]
  #         
  #         # delete the duplicate entries from the spectra data set 
  #         spectra_write <- spectra_write %>% filter(!indvdID %in% deleteIDs)
  #       }
  #     }
  #   }
  #   
  #   
  #   print("number of unique pixelNumbers in the updated spectra_write data frame: ")
  #   print(length(unique(spectra_write$pixelNumber)))
  #   
  #   print("number of rows in updated spectra_write data frame: ")
  #   print(nrow(spectra_write))
  #   
  # }
  # 

```

