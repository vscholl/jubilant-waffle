---
title: "Hyperspectral Analysis"
author: "Victoria Scholl"
date: "12/27/2018"
output: 
  html_document:
    theme: cosmo
    highlight: zenburn
---

## Introduction

This document outlines the workflow that integrates field-based tree measurements with airborne remote sensing data from the National Ecological Observatory Network (NEON). Using points and polygons generated using the [neon_veg](https://github.com/earthlab/neon-veg) workflow, this R code extracts reflectance values for each tree from hyperspectral image data and performs subsequent spectral analysis. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE,
                      results = 'hide')
```

# Extract reflectance spectra 

## Setup 

First, load the required R packages for this analysis. 

```{r load_packages}
# load necessary R packages 
library(rhdf5)
library(rgdal)
library(raster)
library(ggplot2)
library(tidyr)
library(sf)
library(dplyr)
library(data.table) 

# set working directory
setwd("~/github/jubilant-waffle/code/")

# load any local functions in external files 
source("supporting_functions.R")
```

Specify where the hyperspectral data and shapefiles are located. 

* This project is currently structured with "code", "data", and "output" top-level directories.
* Within "data", each NEON site has its own directory named with the site code (such as "NIWO" for Niwot Ridge). 
* The polygon and point shapefiles will be used to clip hyperspectral data to obtain spectral reflectance for each tree location. 

```{r directory_input_output}
# code for NEON site 
site_code <- 'NIWO'

# directory with hyperspectral .h5 files
h5_dir <- paste0('../data/', site_code, '/hyperspectral/')

# directory with shapefiles (tree stem locations and crown polygons)
shapefile_dir <- paste0('../data/', site_code, '/shapefiles/')

# define the output directory. If it doesn't exist already, create it.
check_create_dir('../output/') # create top level "output" directory
out_dir <- paste0('../output/', site_code, '/')
check_create_dir(out_dir) # create output folder for site

# define the "bad bands" wavelength ranges in nanometers, where atmospheric 
# absorption creates unreliable reflectance values. 
# --> Instead, read the bad band ranges from metadata?
bad_band_window_1 <- c(1340, 1445)
bad_band_window_2 <- c(1790, 1955)
```

## Read and pre-process vector data 

Read the shapefiles.
The circular crown poylgons are read in as a SpatialPolygonsDataFrame.
The tree stem locations are read in as a SpatialPointsDataFrame. 
After following the [neon_veg](https://github.com/earthlab/neon-veg) workflow, the *polygons_checked_overlap* shapefile contains polygons that have been checked for overlap with neighboring polygons, preserving those that are most likely visible in the airborne imagery. The *mapped_stems_final* shapefile contains the point locations of the corresponding tree stems. 

```{r read_shapefiles}
# read tree polygons file 
tree_polygons <- rgdal::readOGR(dsn = shapefile_dir,
                           layer = "polygons_checked_overlap")

# read the tree stem locations file
tree_points <- rgdal::readOGR(dsn = shapefile_dir,
                              layer = "mapped_stems_final")
```

For later analysis, these Spatial data frames can be converted to SF objects and additional columns are added to contain the extent information for each tree polygon. 

```{r convert_shapefiles}
# convert polygons and tree locations to SF objects
tree_polygons_sf <- sf::st_as_sf(tree_polygons)
tree_points_sf <- sf::st_as_sf(tree_points) 

# isolate the tree location coordinates 
tree_coords <- tree_points_sf %>% 
  sf::st_coordinates() %>% 
  as.data.frame()

# add new columns for the tree location coordinates 
tree_points_sf$X <- tree_coords$X
tree_points_sf$Y <- tree_coords$Y

# add empty columns for the min and max coordinates for each polygon
tree_polygons_sf$xmin <- NA 
tree_polygons_sf$xmax <- NA 
tree_polygons_sf$ymin <- NA 
tree_polygons_sf$ymax <- NA 

# add the min, max X and Y values to each polygon for filtering 
for (i in 1:nrow(tree_polygons_sf)) {
  tree_polygons_sf$xmin[i] <- as.numeric(sf::st_bbox(tree_polygons_sf$geometry[i])[1])
  tree_polygons_sf$ymin[i] <- as.numeric(sf::st_bbox(tree_polygons_sf$geometry[i])[2])
  tree_polygons_sf$xmax[i] <- as.numeric(sf::st_bbox(tree_polygons_sf$geometry[i])[3])
  tree_polygons_sf$ymax[i] <- as.numeric(sf::st_bbox(tree_polygons_sf$geometry[i])[4])
}

# merge the polygons with tree locations;
# rename the geometry columns to be more descriptive 
tree_polygons_points <- merge(as.data.frame(tree_polygons_sf),
                         as.data.frame(tree_points_sf)
                         [,c("indvdID", "X","Y","geometry")],
                         by="indvdID") %>% 
  dplyr::rename(geometry.polygon = geometry.x, 
                geometry.point = geometry.y)
```

## Read and pre-process raster data 

The hyperspectral data is available in 1km x 1km square tiles.

Read the first tile metadata and reflectance data. 

```{r read_hyperspectral}
# get the names of all HDF5 files to iterate through
h5_list <- list.files(path = h5_dir, full.names = TRUE)
h5_list <- h5_list[grepl("*.h5", h5_list)]

# select first HDF5 file 
h5 <- h5_list[1]
print(h5)

# list the contents of HDF5 file
h5_struct <- rhdf5::h5ls(h5, all=T)

# construct the string using "/Reflectance/Metadata/Coordinate_System",
# without explicitly using a site code 
crs_tag <- h5_struct$group[grepl("/Reflectance/Metadata/Coordinate_System", 
                                 h5_struct$group)][1] 

# read coordinate reference system data
crs_info <- rhdf5::h5read(h5, crs_tag)

# convert "UTM" to lowercase "utm" for proper usage later
crs_info$Proj4 <- CRS(chartr("UTM", "utm", crs_info$Proj4))

# get attributes for the Reflectance dataset.
# construct the string using "/Reflectance/Reflectance_Data"" 
refl_tag <- paste0(h5_struct$group[grepl("/Reflectance", 
                                         h5_struct$group)][1],
                   "/Reflectance_Data")

# read the reflectance metadata
refl_info <- rhdf5::h5readAttributes(h5,refl_tag)

# get the dimensions of the reflectance data
n_rows <- refl_info$Dimensions[1]
n_cols <- refl_info$Dimensions[2]
n_bands <- refl_info$Dimensions[3]

# print dimensions 
print(paste0("# Rows: ", as.character(n_rows)))
print(paste0("# Columns: ", as.character(n_cols)))
print(paste0("# Bands: ", as.character(n_bands)))

# read the wavelengths of the hyperspectral image bands
wavelength_tag <- paste0(h5_struct$group[grepl("/Reflectance/Metadata/Spectral_Data", 
                                               h5_struct$group)][1],
                         "/Wavelength")
wavelengths <- rhdf5::h5read(h5,
                             wavelength_tag)

# define spatial extent: extract resolution and origin coordinates
map_info <- unlist(strsplit(crs_info$Map_Info, 
                            split = ", "))
res_x <- as.numeric(map_info[6])
res_y <- as.numeric(map_info[7])
x_min <- as.numeric(map_info[4])
y_max <- as.numeric(map_info[5])

# calculate the maximum X and minimum Y values 
x_max <- (x_min + (n_cols * res_x))
y_min <- (y_max - (n_rows * res_y))
tile_extent <- raster::extent(x_min, x_max, y_min, y_max)

# read reflectance data for all bands
refl <- rhdf5::h5read(h5, refl_tag,
                      index = list(1:n_bands, 1:n_cols, 1:n_rows))

# view and apply scale factor to convert integer values to reflectance [0,1]
# and data ignore value
scale_factor <- refl_info$Scale_Factor
data_ignore <- refl_info$Data_Ignore_Value
refl[refl == data_ignore] <- NA 
refl_scaled <- refl / scale_factor
```

## Extract reflectance spectra for each tree from hyperspectral imagery 

As this [Earth Lab tutorial](https://www.earthdatascience.org/courses/earth-analytics/lidar-raster-data-r/crop-raster-data-in-r/) describes, there is an **extract** function within the **raster** R package. It requires raster and and vector objects. 

As for the vector layers, let's figure out which trees are within the current tile and convert their corresponding points and polygons from SF objects to SpatialPoints and SpatialPolygons forms. 

```{r polygons_in_tile}
# figure out which trees are within the current tile 
polygons_in <- tree_polygons_points %>% 
  dplyr::filter(xmin >= tile_extent@xmin & 
                xmax < tile_extent@xmax & 
                ymin >= tile_extent@ymin & 
                ymax < tile_extent@ymax)

print(paste0(as.character(nrow(polygons_in))," polygons in current tile"))

# if no polygons are within the current tile, skip to the next one
if (nrow(polygons_in)==0){
  print("no trees located within current tile... skipping to next tile")
  next
}

# convert from SF obect to SpatialPolygons object for clipping
polygons_in_sp <- sf::as_Spatial(polygons_in$geometry.polygon,
                                 IDs = as.character(polygons_in$indvdID))
points_in_sp <- sf::as_Spatial(polygons_in$geometry.point,
                                 IDs = as.character(polygons_in$indvdID))

```

Let's stack up all of the hyperspectral bands into a RasterStack (a collection of Raster layers with the same spatial resolution and extent) as the raster input to this function. 

```{r create_hyperspectral_rasterstack}

# create georeferenced raster using band 1 
r1 <- (refl_scaled[1,,]) # convert first band to matrix
r1 <- raster::raster(r1, crs = crs_info$Proj4)
extent(r1) <- tile_extent

# start the raster stack with first band 
s <- raster::stack(r1)

# loop through bands and create a giant rasterstack with 426 (n_bands) bands
for(b in 2:n_bands){
  print(b)
  
  # create raster with current band
  r <- (refl_scaled[b,,]) # convert to matrix
  r <- raster::raster(r, crs = crs_info$Proj4)
  extent(r) <- tile_extent
  
  # add additional band to the stack with the addLayer function
  s <- raster::addLayer(s, r)
  
}

# adjust the names for each layer in raster stack to correspond to wavelength
names(s) <- round(wavelengths)
```

Let's clip the scaled hyperspectral reflectance rasterstack with the tree polygons to extract reflectance curves for each tree stem point, and within each polygon area. 

```{r extract_rasterstack_spectra}
# clip the hyperspectral raster stack with the polygons within current tile.
# the returned objects are data frames, each row corresponds to a pixel in the
# hyperspectral imagery. The ID number refers to which polygon or point that 
# the pixel belongs to. A large polygon will lead to many extracted pixels
# (many rows in the output data frame)
extracted_point_spectra <- raster::extract(s, points_in_sp, df = TRUE)
extracted_polygon_spectra <- raster::extract(s, polygons_in_sp, df = TRUE)
```

In the resulting data frames, each row contains a single reflectance spectrum, corresponding to a single pixel location (x,y) in the hyperspectral imagery. 

* In the **extracted_point_spectra**, there is one row per tree stem.
* In the **extracted_polygon_spectra**, there are multiple rows per tree polygon. A larger polygon will intersect with more pixels, producing more rows for trees with large crowns in this output data frame. 
* The "ID" column contains an integer to identify which of the trees within the tile that the spectra belong to. 

For instance, let's take a look at the first 12 rows of the extracted_point_spectra. Thee first 5 columns are displayed here, which contain "ID" values and the first few reflectance values for low wavelengths around 380nm. Notice that the ID column contains values that increase monotonically with rows for the extracted point spectra, since each tree stem point intersects with a single pixel in the hyperspectral imagery. 

```{r head_point_spectra, results = TRUE}
head(extracted_point_spectra[,1:5], n = 12)
```

The first 12 rows of the extracted_polygon_spectra look different (specifically, the **ID** column). Rows 1 through 10 have an ID of 1. This means that tree 1 in the SpatialPolygons object intersected with 10 pixels in the hyperspectral imagery, so there are 10 spectra available for analysis. Tree 2 in the SpatialPolygons object intersects with more than 1 pixel too. We can see the beginning of those spectra in rows 11 and 12 below. 

```{r head_polygon_spectra, results = TRUE}
head(extracted_polygon_spectra[,1:5], n = 12)
```


Write the spectral reflectance data to file for each tree. Combine each spectrum with more information about each corresponding tree (including the individual ID, species, and height).
For the extracted spectra with more than one row per tree, adjust the "ID" column to reflect how many spectra correspond to each tree. 

```{r combine_metadata_write_spectra, results = TRUE}

# create polygon metadata data frame 
polygon_metadata <- data.frame(individualID = polygons_in$indvdID,
                              scientificName = polygons_in$scntfcN,
                              taxonID = polygons_in$taxonID,
                              maxCrownDiameter = polygons_in$crownDm,
                              height = polygons_in$height,
                              X = polygons_in$X,
                              Y = polygons_in$Y,
                              # create ID column to pair the polygon metadata with  spectra
                              ID =  1:nrow(polygons_in))

# create a list of increasing integer counts to keep track of how many rows 
# (pixels or spectra) belong to each tree 
for (i in unique(extracted_polygon_spectra$ID)){
  if(i==1){
    counts = 1:sum(extracted_polygon_spectra$ID==i)
  }
  else{
    counts = append(counts, 1:sum(extracted_polygon_spectra$ID==i))
  }
}

# combine the additional data with each spectrum for writing to file
spectra_write <- merge(polygon_metadata,
                       as.data.frame(extracted_polygon_spectra),
                       by="ID") %>% 
  mutate(spectra_count = counts)%>% 
  select(ID, spectra_count, everything())
  
# take a look at the first rows of the spectra data to write 
head(spectra_write[,1:10] %>% select(-c(scientificName,X,Y)))


# write the spectral data to file for future analysis 
write.csv(spectra_write, file = paste0(out_dir,
                                       "spectral_reflectance_",
                                        as.character(tile_extent@xmin),"_",
                                        as.character(tile_extent@ymin),".csv")) 
  
```

The accompanying *hyperspectral_analysis.R* script loops through all of the HDF5 files and extracts spectra using the steps described above. The spectra are written to separate .csv files for each tile, then combined into a single .csv tile for subsequent analysis. 

The code below reads the .csv file with all spectra for different types of shapefiles.

(1) All of the spectra extracted at **each stem location** (in theory, the central pixel per tree crown). *One pixel extracted per tree.*

(2) All of the spectra ectracted within the **"checked_overlap" polygons** generated by the neon_veg workflow. *The number of spectra per tree is based on the size/location of each polygon and how many pixels it intersects with.* Since these polygons may be clipped based on their proximity and height compared to neighboring trees, there will be fewer polygons for this scenario compared to the next. 

(3) All of the spectra extracted using the **"buffer" argument** in the raster::extract function. The buffer size was set based on the max_diameter of each tree crown. *The number of spectra per tree is based on the size/location of each polygon and how many pixels it intersects with.* 

```{r read_all_spectra}
# read all of the reflectance spectra extracted for all trees in current site.
# remove the column labeled "X.1", which just has row numbers. 


# (1) stem point locations 
out_description <- "stem_points" # stem point locations 
spectra_all_points_filename <- paste0(out_dir, 
                                             site_code,
                                             "_spectral_reflectance_ALL_",
                                              out_description, ".csv")
spectra_all_points <- as.data.frame(read.csv(spectra_all_points_filename)) %>% 
                  select(-X.1)


# (2) checked_overlap polygons
out_description <- "polygons_checked_overlap_max_diameter" # checked_overlap polygons
spectra_all_overlapPolygons_filename <- paste0(out_dir, 
                                             site_code,
                                             "_spectral_reflectance_ALL_",
                                              out_description, ".csv")
spectra_all_overlapPolygons <- as.data.frame(read.csv(spectra_all_overlapPolygons_filename)) %>% 
                  select(-X.1)


# (3) buffer_max_diameter
out_description <- "buffer_max_diameter" # buffer of (maxCrownDiameter / 2)
spectra_all_bufferPolygons_filename <- paste0(out_dir, 
                                             site_code,
                                             "_spectral_reflectance_ALL_",
                                              out_description, ".csv")
spectra_all_bufferPolygons <- as.data.frame(read.csv(spectra_all_bufferPolygons_filename)) %>% 
                  select(-X.1)




spectra_all <- spectra_all_points
# filter the spectra to reduce the number of them for quick visualization 
# figure out how to extract spectra for the center pixels most efficiently, make a 
# function out of hyperspectral_analysis.R? 
set.seed(12)
spectra_all <- spectra_all[sample(nrow(spectra_all), size = 100),]
#spectra_all <- spectra_write # use the single tile spectra from above for quick viz 
```



# Spectral Analysis

## Plot reflectance spectra

Plot the reflectance spectra as a function of wavelength. First, let's see them all on a single graph, colored by species. 

```{r plot_spectra}

# keep just the reflectance values along with individual ID and species
# for the first tree
spectra_1 <- spectra_all[1,] %>% 
                dplyr::select(-c(X,Y,ID))

# organize the data into a data frame where the first column contains
# the individualID, second column contains scientific name, 
# followed by additional tree metadata and finally
# reflectance per wavelength.  
spectra_plot <- tidyr::gather(spectra_1,
                              key = wavelength,
                              value = "reflectance",
                              -individualID,
                              -scientificName,
                              -taxonID,
                              -maxCrownDiameter,
                              -height,
                              -spectra_count)
# add the actual wavelenth values into the wavelengths column
spectra_plot$wavelength <- wavelengths

# loop through the remaining spectra and repeat 
for (i in 2:nrow(spectra_all)){
  spectra_current <- spectra_all[i,] %>% 
                        dplyr::select(-c(X,Y,ID))
  spectra_current <- tidyr::gather(spectra_current,
                                key = wavelength,
                                value = "reflectance",
                                -individualID,
                                -scientificName,
                                -taxonID,
                                -maxCrownDiameter,
                                -height,
                                -spectra_count)
  spectra_current$wavelength <- wavelengths
  
  spectra_plot <- rbind(spectra_plot, spectra_current)
  
}

# remove the first reflectance value 
spectra_plot <- spectra_plot[spectra_plot$wavelength > 385,]

# remove the bad bands 
remove_bands <- wavelengths[(wavelengths > bad_band_window_1[1] & 
                            wavelengths < bad_band_window_1[2]) | 
                           (wavelengths > bad_band_window_2[1] & 
                            wavelengths < bad_band_window_2[2])]

spectra_plot$reflectance[spectra_plot$wavelength %in% remove_bands] <- NA
```

```{r point_spectra_single_plot, results=TRUE}
# plot all spectra on single plot 
# adjust line width and alpha for better visibility with many curves
ggplot(data = spectra_plot, 
       aes(x = wavelength, 
           y = reflectance, 
           colour = taxonID)) +
  geom_line(aes(group = individualID), size = 0.5, alpha = 0.7) + 
  labs(x = "wavelength (nm)", 
       color = "species") + 
  ggtitle("Hyperspectral reflectance extracted per pixel") +
          scale_color_manual(values = c("#d7191c", "#fdae61", "#abdda4", "#2b83ba")
  )
```

We can also plot the reflectance spectra on four separate plots, one per species. 

```{r point_spectra_multi_plot, results=TRUE}
# Use facet_grid for a separate plot per species 
ggplot(data = spectra_plot, 
       aes(x = wavelength, 
           y = reflectance, 
           colour = taxonID)) +
  geom_line(aes(group = individualID), alpha = 0.5) + 
  facet_wrap(. ~ taxonID, ncol = 2) + 
  labs(x = "wavelength (nm)", color = "species") + 
  ggtitle("Hyperspectral reflectance extracted per pixel") + 
  scale_color_manual(values = c("#d7191c", "#fdae61", "#abdda4", "#2b83ba"))
```

To assess the difference between a single stem location and a collection of pixels within a tree crown polygon, let's plot a single reflectance spectrum compared to a series of them. 

```{r plot_compare_point_polygon}
# all reflectance spectra for a tree polygon
spectra_tree <- spectra_plot %>% 
              filter(individualID==as.character(spectra_plot$individualID[1])) 

# single reflectance spectrum for a tree stem point
spectrum_tree <- spectra_tree %>% 
                  filter(spectra_count == spectra_tree$spectra_count[1])

# plot reflectance spectrum for a single tree stem location pixel 
ggplot(data = spectrum_tree, 
       aes(x = wavelength, 
           y = reflectance, 
           colour = taxonID)) +
  geom_line(aes(group = individualID), size = 0.3, alpha = 0.7) + 
  labs(x = "wavelength (nm)") + 
  ggtitle("Hyperspectral reflectance for a single pixel within polygon") +
          scale_color_manual(values = c("#1c9099")
  )

# plot containing multiple pixels within a tree polygon
ggplot(data = spectra_tree, 
       aes(x = wavelength, 
           y = reflectance, 
           colour = taxonID)) +
  geom_line(aes(group = individualID), size = 0.3, alpha = 0.7) + 
  labs(x = "wavelength (nm)") + 
  ggtitle("Hyperspectral reflectance for multiple pixels within tree polygon") +
          scale_color_manual(values = c("#1c9099")
  )
```



To visualize the variation of spectra per species, let's add shadded regions to capture the minimum and maximum reflectance per wavelength and see if there are any notable divergences between species. 

```{r eval = FALSE}

# calculate mean reflectance per species
mean_reflectance <- stats::aggregate(spectra_all[,10:ncol(spectra_all)], 
                                     by = list(taxonID = spectra_all$taxonID),
                                     FUN = mean) 
min_reflectance <- stats::aggregate(spectra_all[,10:ncol(spectra_all)], 
                                     by = list(taxonID = spectra_all$taxonID),
                                     FUN = min) 
max_reflectance <- stats::aggregate(spectra_all[,10:ncol(spectra_all)], 
                                     by = list(taxonID = spectra_all$taxonID),
                                     FUN = max) 

# create a LUT that matches actual wavelength values with the column names,
# X followed by the rounded wavelength values. 
wavelength_lut <- data.frame(wavelength = wavelengths,
                             xwavelength = paste0("X",as.character(round(wavelengths))))

# use the gather function makes wide data longer:
# https://uc-r.github.io/tidyr 
# so the reflectance data can easily be grouped by species, 
# and the mean/min/max reflectance values can be selected for a ribbon plot. 
mean_refl_tidy <- tidyr::gather(mean_reflectance,
                                key = xwavelength,
                                value = "mean_reflectance",
                                X381:X2510) %>%
  dplyr::left_join(wavelength_lut, by="xwavelength") 

# add on the min reflectance column with the same format 
max_refl_tidy <- tidyr::gather(max_reflectance,
                                key = xwavelength,
                                value = "max_reflectance",
                                X381:X2510)

min_refl_tidy <- tidyr::gather(min_reflectance,
                                key = xwavelength,
                                value = "min_reflectance",
                                X381:X2510)

# combine the mean, min, man reflectance data into one long data frame
refl_tidy <- merge.data.frame(mean_refl_tidy,
                              max_refl_tidy) %>% 
  merge.data.frame(min_refl_tidy) %>% 
  select(-xwavelength) %>%          # remove the Xwavelength values 
  select(wavelength, everything())  # reorder to wavelength column is first



# remove the first reflectance value 
refl_tidy <- refl_tidy[refl_tidy$wavelength > 385,]

# remove the bad bands 
refl_tidy$mean_reflectance[refl_tidy$wavelength %in% remove_bands] <- NA
refl_tidy$max_reflectance[refl_tidy$wavelength %in% remove_bands] <- NA
refl_tidy$min_reflectance[refl_tidy$wavelength %in% remove_bands] <- NA


# specify the colors for the reflectance curves & shading around them 
shading_colors <- c("#d7191c", "#fdae61", "#abdda4", "#2b83ba")
species <- sort(unique(spectra_all$taxonID)) #alphabetical so colors match plot above
shading_alpha <- 0.3

# generate the ribbon plot
ggplot(refl_tidy, 
       aes(x = wavelength, y = mean_reflectance, color = taxonID)) + 
      
      # shaded ribbon from min to max for each species
      # can't get the shading colors to match the lines
      #geom_ribbon(aes(ymin = min_reflectance,
      #                ymax = max_reflectance,
      #                alpha = 0.1,
      #                fill = taxonID)) + 
  
      # ABLAL
      geom_ribbon(data = refl_tidy[refl_tidy$taxonID == species[1], ],
                    aes(ymin = min_reflectance, ymax = max_reflectance),
                  colour=NA,
                  alpha = shading_alpha,
                  fill = shading_colors[1],
                  show.legend = F) + 
  
      # PICOL
      geom_ribbon(data = refl_tidy[refl_tidy$taxonID == species[2], ],
                    aes(ymin = min_reflectance, ymax = max_reflectance),
                  colour=NA,
                  alpha = shading_alpha,
                  fill = shading_colors[2],
                  show.legend = F) + 

      # PIEN
      geom_ribbon(data = refl_tidy[refl_tidy$taxonID == species[3], ],
                    aes(ymin = min_reflectance, ymax = max_reflectance),
                  colour=NA,
                  alpha = shading_alpha,
                  fill = shading_colors[3],
                  show.legend = F) + 
  
      # PIFL2
      geom_ribbon(data = refl_tidy[refl_tidy$taxonID == species[4], ],
                    aes(ymin = min_reflectance, ymax = max_reflectance),
                  colour=NA,
                  alpha = shading_alpha,
                  fill = shading_colors[4],
                  show.legend = F) + 

  
      # mean reflectance line
      # placing this after the ribbon shading so the mean curves are visible
      geom_line(size = 0.5, alpha = 1) + 
  
      scale_color_manual(values = shading_colors) + 
  
      # hide the "alpha" legend
      guides(alpha=FALSE) + 

      # label X and Y axes 
      labs(x = "wavelength (nm)", y = "reflectance") + 
  
      # main plot title  
      ggtitle(paste0("Mean Hyperspectral reflectance per species \n",
                    "(shading shows minimum and maximum refl range per wavelength)")) 

```

## Spectral seperability analysis

R packages and resources to potentially utilize:

* [separability](https://www.rdocumentation.org/packages/spatialEco/versions/1.1-0/topics/separability) 

* [manual calculation](https://stats.stackexchange.com/questions/78849/measure-for-separability)





