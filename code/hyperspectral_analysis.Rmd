---
title: "Hyperspectral Analysis"
author: "Victoria Scholl"
date: "12/27/2018"
output: 
  html_document:
    theme: cosmo
    highlight: zenburn
---

## Introduction

This document outlines the workflow that integrates field-based tree measurements with airborne remote sensing data from the National Ecological Observatory Network (NEON). Using points and polygons generated using the [neon_veg](https://github.com/earthlab/neon-veg) workflow, this R code extracts reflectance values for each tree from hyperspectral image data and performs subsequent spectral analysis. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE,
                      results = 'hide')
```

# Extract reflectance spectra 

## Setup 

First, load the required R packages for this analysis. 

```{r load_packages}
# load necessary R packages 
library(rhdf5)
library(rgdal)
library(raster)
library(ggplot2)
library(tidyr)
library(sf)
library(dplyr)
library(data.table) 

# set working directory
setwd("~/github/jubilant-waffle/code/")

# load any local functions in external files 
source("supporting_functions.R")
```

Specify where the hyperspectral data and shapefiles are located. 

* This project is currently structured with "code", "data", and "output" top-level directories.
* Within "data", each NEON site has its own directory named with the site code (such as "NIWO" for Niwot Ridge). 
* The polygon and point shapefiles will be used to clip hyperspectral data to obtain spectral reflectance for each tree location. 

```{r directory_input_output}
# code for NEON site 
site_code <- 'NIWO'

# directory with hyperspectral .h5 files
h5_dir <- paste0('../data/', site_code, '/hyperspectral/')

# directory with shapefiles (tree stem locations and crown polygons)
shapefile_dir <- paste0('../data/', site_code, '/shapefiles/')

# define the output directory. If it doesn't exist already, create it.
check_create_dir('../output/') # create top level "output" directory
out_dir <- paste0('../output/', site_code)
check_create_dir(out_dir) # create output folder for site
```

## Read and pre-process vector data 

Read the shapefiles.
The circular crown poylgons are read in as a SpatialPolygonsDataFrame.
The tree stem locations are read in as a SpatialPointsDataFrame. 
After following the [neon_veg](https://github.com/earthlab/neon-veg) workflow, the *polygons_checked_overlap* shapefile contains polygons that have been checked for overlap with neighboring polygons, preserving those that are most likely visible in the airborne imagery. The *mapped_stems_final* shapefile contains the point locations of the corresponding tree stems. 

```{r read_shapefiles}
# read tree polygons file 
tree_polygons <- rgdal::readOGR(dsn = shapefile_dir,
                           layer = "polygons_checked_overlap")

# read the tree stem locations file
tree_points <- rgdal::readOGR(dsn = shapefile_dir,
                              layer = "mapped_stems_final")
```

For later analysis, these Spatial data frames can be converted to SF objects and additional columns are added to contain the extent information for each tree polygon. 

```{r convert_shapefiles}
# convert polygons and tree locations to SF objects
tree_polygons_sf <- sf::st_as_sf(tree_polygons)
tree_points_sf <- sf::st_as_sf(tree_points) 

# isolate the tree location coordinates 
tree_coords <- tree_points_sf %>% 
  sf::st_coordinates() %>% 
  as.data.frame()

# add new columns for the tree location coordinates 
tree_points_sf$X <- tree_coords$X
tree_points_sf$Y <- tree_coords$Y

# add empty columns for the min and max coordinates for each polygon
tree_polygons_sf$xmin <- NA 
tree_polygons_sf$xmax <- NA 
tree_polygons_sf$ymin <- NA 
tree_polygons_sf$ymax <- NA 

# add the min, max X and Y values to each polygon for filtering 
for (i in 1:nrow(tree_polygons_sf)) {
  tree_polygons_sf$xmin[i] <- as.numeric(sf::st_bbox(tree_polygons_sf$geometry[i])[1])
  tree_polygons_sf$ymin[i] <- as.numeric(sf::st_bbox(tree_polygons_sf$geometry[i])[2])
  tree_polygons_sf$xmax[i] <- as.numeric(sf::st_bbox(tree_polygons_sf$geometry[i])[3])
  tree_polygons_sf$ymax[i] <- as.numeric(sf::st_bbox(tree_polygons_sf$geometry[i])[4])
}

# merge the polygons with tree locations;
# rename the geometry columns to be more descriptive 
tree_polygons_points <- merge(as.data.frame(tree_polygons_sf),
                         as.data.frame(tree_points_sf)
                         [,c("indvdID", "X","Y","geometry")],
                         by="indvdID") %>% 
  dplyr::rename(geometry.polygon = geometry.x, 
                geometry.point = geometry.y)
```

## Read and pre-process raster data 

The hyperspectral data is available in 1km x 1km square tiles.

Read the first tile metadata and reflectance data. 

```{r read_hyperspectral}
# get the names of all HDF5 files to iterate through
h5_list <- list.files(path = h5_dir, full.names = TRUE)
h5_list <- h5_list[grepl("*.h5", h5_list)]

# select first HDF5 file 
h5 <- h5_list[1]
print(h5)

# list the contents of HDF5 file
h5_struct <- rhdf5::h5ls(h5, all=T)

# construct the string using "/Reflectance/Metadata/Coordinate_System",
# without explicitly using a site code 
crs_tag <- h5_struct$group[grepl("/Reflectance/Metadata/Coordinate_System", 
                                 h5_struct$group)][1] 

# read coordinate reference system data
crs_info <- rhdf5::h5read(h5, crs_tag)

# convert "UTM" to lowercase "utm" for proper usage later
crs_info$Proj4 <- CRS(chartr("UTM", "utm", crs_info$Proj4))

# get attributes for the Reflectance dataset.
# construct the string using "/Reflectance/Reflectance_Data"" 
refl_tag <- paste0(h5_struct$group[grepl("/Reflectance", 
                                         h5_struct$group)][1],
                   "/Reflectance_Data")

# read the reflectance metadata
refl_info <- rhdf5::h5readAttributes(h5,refl_tag)

# get the dimensions of the reflectance data
n_rows <- refl_info$Dimensions[1]
n_cols <- refl_info$Dimensions[2]
n_bands <- refl_info$Dimensions[3]

# print dimensions 
print(paste0("# Rows: ", as.character(n_rows)))
print(paste0("# Columns: ", as.character(n_cols)))
print(paste0("# Bands: ", as.character(n_bands)))

# read the wavelengths of the hyperspectral image bands
wavelength_tag <- paste0(h5_struct$group[grepl("/Reflectance/Metadata/Spectral_Data", 
                                               h5_struct$group)][1],
                         "/Wavelength")
wavelengths <- rhdf5::h5read(h5,
                             wavelength_tag)

# define the "bad bands" wavelength ranges in nanometers, where atmospheric 
# absorption creates unreliable reflectance values. 
# --> Read the bad band ranges from metadata? <--
bad_band_window_1 <- c(1340, 1445)
bad_band_window_2 <- c(1790, 1955)

# define spatial extent: extract resolution and origin coordinates
map_info <- unlist(strsplit(crs_info$Map_Info, 
                            split = ", "))
res_x <- as.numeric(map_info[6])
res_y <- as.numeric(map_info[7])
x_min <- as.numeric(map_info[4])
y_max <- as.numeric(map_info[5])

# calculate the maximum X and minimum Y values 
x_max <- (x_min + (n_cols * res_x))
y_min <- (y_max - (n_rows * res_y))
tile_extent <- raster::extent(x_min, x_max, y_min, y_max)

# print the extent of the current tile
print("tile extent: ")
tile_extent

# read reflectance data for all bands
refl <- rhdf5::h5read(h5, refl_tag,
                      index = list(1:n_bands, 1:n_cols, 1:n_rows))

# view and apply scale factor to convert integer values to reflectance [0,1]
# and data ignore value
scale_factor <- refl_info$Scale_Factor
data_ignore <- refl_info$Data_Ignore_Value
refl[refl == data_ignore] <- NA 
refl_scaled <- refl / scale_factor
```

## Extract reflectance spectra for each tree from hyperspectral imagery 

As this [Earth Lab tutorial](https://www.earthdatascience.org/courses/earth-analytics/lidar-raster-data-r/crop-raster-data-in-r/) describes, there is an **extract** function within the **raster** R package. It requires raster and and vector objects. Let's stack up all of the hyperspectral bands into a rasterstack as the raster input to this function. 

```{r create_hyperspectral_rasterstack}

# create georeferenced raster using band 1 
r1 <- (refl_scaled[1,,]) # convert first band to matrix
r1 <- raster::raster(r1, crs = crs_info$Proj4)
extent(r1) <- tile_extent

# start the raster stack with first band 
s <- raster::stack(r1)

# loop through bands and create a giant rasterstack with 426 (n_bands) bands
for(b in 2:n_bands){
  print(b)
  
  # create raster with current band
  r <- (refl_scaled[b,,]) # convert to matrix
  r <- raster::raster(r, crs = crs_info$Proj4)
  extent(r) <- tile_extent
  
  # add additional band to the stack with the addLayer function
  s <- raster::addLayer(s, r)
  
}

# adjust the names for each layer in raster stack to correspond to wavelength
names(s) <- round(wavelengths)
```

As for the vector layers, let's figure out which trees are within the current til and convert their corresponding points and polygons from SF objects to SpatialPoints and SpatialPolygons forms. 

```{r polygons_in_tile}
# figure out which trees are within the current tile 
polygons_in <- tree_polygons_points %>% 
  dplyr::filter(xmin > tile_extent@xmin & 
                  xmax < tile_extent@xmax & 
                  ymin > tile_extent@ymin & 
                  ymax < tile_extent@ymax)

print(paste0(as.character(nrow(polygons_in))," polygons in current tile"))

# if no polygons are within the current tile, skip to the next one
if (nrow(polygons_in)==0){
  print("no trees located within current tile")
  next
}

# convert from SF obect to SpatialPolygons object for clipping
polygons_in_sp <- sf::as_Spatial(polygons_in$geometry.polygon,
                                 IDs = as.character(polygons_in$indvdID))
points_in_sp <- sf::as_Spatial(polygons_in$geometry.point,
                                 IDs = as.character(polygons_in$indvdID))

```

Let's clip the scaled hyperspectral reflectance rasterstack with the tree polygons to extract reflectance curves for each tree stem point, and within each polygon area. 

```{r extract_rasterstack_spectra}
# clip the hyperspectral raster stack with the polygons within current tile.
# the returned objects are data frames, each row corresponds to a pixel in the
# hyperspectral imagery. The ID number refers to which polygon or point that 
# the pixel belongs to. A large polygon will lead to many extracted pixels
# (many rows in the output data frame)
extracted_polygon_spectra <- raster::extract(s, polygons_in_sp, df = TRUE)
extracted_point_spectra <- raster::extract(s, points_in_sp, df = TRUE)
```

In the resulting data frames, each row contains a single reflectance spectrum, corresponding to a single pixel location (x,y) in the hyperspectral imagery. 

* In the **extracted_point_spectra**, there is one row per tree stem.
* In the **extracted_polygon_spectra**, there are multiple rows per tree polygon. A larger polygon will intersect with more pixels, producing more rows for trees with large crowns in this output data frame. 
* The "ID" column contains an integer to identify which of the trees within the tile that the spectra belong to. 

For instance, let's take a look at the first 12 rows of the extracted_point_spectra. Thee first 5 columns are displayed here, which contain "ID" values and the first few reflectance values for low wavelengths around 380nm. Notice that the ID column contains values that increase monotonically with rows for the extracted point spectra, since each tree stem point intersects with a single pixel in the hyperspectral imagery. 

```{r head_point_spectra, results = TRUE}
head(extracted_point_spectra[,1:5], n = 12)
```

The first 12 rows of the extracted_polygon_spectra look different. Rows 1 through 10 have an ID of 1. This means that tree 1 in the SpatialPolygons object intersected with 10 pixels in the hyperspectral imagery, so there are 10 spectra available for analysis. Tree 2 in the SpatialPolygons object intersects with more than 1 pixel too. We can see the beginning of those spectra in rows 11 and 12 below. 

```{r head_polygon_spectra, results = TRUE}
head(extracted_polygon_spectra[,1:5], n = 12)
```


Write the spectral reflectance data to file for each tree. Combine each spectrum with more information about each corresponding tree (including the individual ID, species, and height).
For the extracted spectra with more than one row per tree, adjust the 

```{r combine_write_spectra}

# combine the additional data with each spectrum for writing to file
spectra_write <- data.frame(individualID = polygons_in$indvdID,
                              scientificName = polygons_in$scntfcN,
                              taxonID = polygons_in$taxonID,
                              maxCrownDiameter = polygons_in$crownDm,
                              height = polygons_in$height,
                              X = polygons_in$X,
                              Y = polygons_in$Y,
                              as.data.frame(extracted_point_spectra))
  
write.csv(spectra_write, file = paste0(out_dir,
                                       "spectral_reflectance_",
                                        as.character(tile_extent@xmin),"_",
                                        as.character(tile_extent@ymin),".csv")) 
  
```

## Plot reflectance spectra

Plot the reflectance spectra as a function of wavelength. First, let's see them all on a single graph, colored by species. 

```{r plot_spectra}

# VS_NOTE - LOOP THROUGH ALL TILES AND READ ALL SPECTRA INTO SINGLE DATA FRAME
spectra_all <- spectra_write # single tile for testing

# keep just the reflectance values along with individual ID and species
# for the first tree
spectra_1 <- spectra_all[1,] %>% 
                dplyr::select(-c(X,Y,ID))

# organize the data into a data frame where the first column contains
# the individual ID, second column contains scientific name, 
# third column contains wavelength, and fourth column contains
# reflectance per wavelength.  
spectra_plot <- tidyr::gather(spectra_1,
                              key = wavelength,
                              value = "reflectance",
                              -individualID,
                              -scientificName,
                              -taxonID,
                              -maxCrownDiameter,
                              -height)
# add the actual wavelenth values into the wavelengths column
spectra_plot$wavelength <- wavelengths

# loop through the remaining spectra and repeat 
for (i in 2:nrow(spectra_all)){
  spectra_current <- spectra_all[i,] %>% 
                        dplyr::select(-c(X,Y,ID))
  spectra_current <- tidyr::gather(spectra_current,
                                key = wavelength,
                                value = "reflectance",
                                -individualID,
                                -scientificName,
                                -taxonID,
                                -maxCrownDiameter,
                                -height)
  spectra_current$wavelength <- wavelengths
  
  spectra_plot <- rbind(spectra_plot, spectra_current)
  
}

# remove the first reflectance value 
spectra_plot <- spectra_plot[spectra_plot$wavelength > 385,]

# remove the bad bands 
remove_bands <- wavelengths[(wavelengths > bad_band_window_1[1] & 
                            wavelengths < bad_band_window_1[2]) | 
                           (wavelengths > bad_band_window_2[1] & 
                            wavelengths < bad_band_window_2[2])]

spectra_plot$reflectance[spectra_plot$wavelength %in% remove_bands] <- NA
```

```{r point_spectra_single_plot, results=TRUE}
# plot all spectra on single plot 
legend_labels = c('a','b','c','d')
ggplot(data = spectra_plot, 
       aes(x = wavelength, 
           y = reflectance, 
           colour = taxonID)) +
  geom_line(aes(group = individualID)) + 
  labs(x = "wavelength (nm)", 
       color = "species") + 
  ggtitle("Hyperspectral reflectance extracted per center pixel") +
          scale_color_manual(values = c("#d7191c", "#fdae61", "#abdda4", "#2b83ba")
  )
```

We can also plot the reflectance spectra on four separate plots, one per species. 

```{r point_spectra_multi_plot, results=TRUE}
# Use facet_grid for a separate plot per species 
ggplot(data = spectra_plot, 
       aes(x = wavelength, 
           y = reflectance, 
           colour = taxonID)) +
  geom_line(aes(group = individualID), alpha = 0.5) + 
  facet_wrap(. ~ taxonID, ncol = 2) + 
  labs(x = "wavelength (nm)", color = "species") + 
  ggtitle("Hyperspectral reflectance extracted per center pixel") + 
  scale_color_manual(values = c("#d7191c", "#fdae61", "#abdda4", "#2b83ba"))
```

To visualize the variation of spectra per species, let's add shadded regions to capture the minimum and maximum reflectance per wavelength and see if there are any notable divergences between species. 

```{r}
# for each species, plot the mean reflectance curve with the variation
# shaded around it 


```

## Spectral seperability analysis
