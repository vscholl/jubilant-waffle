---
title: "Hyperspectral Analysis"
author: "Victoria Scholl"
date: "12/27/2018"
output: 
  html_document:
    theme: cosmo
    highlight: zenburn
---

This document outlines the workflow that integrates field-based tree measurements with airborne remote sensing data from the National Ecological Observatory Network (NEON). 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE,
                      results = 'hide')
```

First, load the required R packages for this analysis. 

```{r load_packages}
# load necessary R packages 
library(rhdf5)
library(rgdal)
library(raster)
library(ggplot2)
library(tidyr)
library(sf)
library(dplyr)
library(data.table) 

# set working directory
setwd("~/github/jubilant-waffle/code/")

# load any local functions in external files 
source("supporting_functions.R")
```

Specify where the hyperspectral data and shapefiles are located. 

* This project is currently structured with "code", "data", and "output" top-level directories.
* Within "data", each NEON site has its own directory named with the site code (such as "NIWO" for Niwot Ridge). 
* The polygon and point shapefiles will be used to clip hyperspectral data to obtain spectral reflectance for each tree location. 

```{r directory_input_output}
# code for NEON site 
site_code <- 'NIWO'

# directory with hyperspectral .h5 files
h5_dir <- paste0('../data/', site_code, '/hyperspectral/')

# directory with shapefiles (tree stem locations and crown polygons)
shapefile_dir <- paste0('../data/', site_code, '/shapefiles/')

# define the output directory. If it doesn't exist already, create it.
check_create_dir('../output/') # create top level "output" directory
out_dir <- paste0('../output/', site_code)
check_create_dir(out_dir) # create output folder for site
```

Read the shapefiles.
The circular crown poylgons are read in as a SpatialPolygonsDataFrame.
The tree stem locations are read in as a SpatialPointsDataFrame. 
After following the [neon_veg](https://github.com/earthlab/neon-veg) workflow, .....

```{r read_shapefiles}
# read tree polygons file 
tree_polygons <- rgdal::readOGR(dsn = shapefile_dir,
                           layer = "polygons_checked_overlap")

# read the tree stem locations file
tree_points <- rgdal::readOGR(dsn = shapefile_dir,
                              layer = "mapped_stems_final")
```

For later analysis, these Spatial data frames can be converted to SF objects and additional columns are added to contain the extent information for each tree polygon. 

```{r convert_shapefiles}
# convert polygons and tree locations to SF objects
tree_polygons_sf <- sf::st_as_sf(tree_polygons)
tree_points_sf <- sf::st_as_sf(tree_points) 

# isolate the tree location coordinates 
tree_coords <- tree_points_sf %>% 
  sf::st_coordinates() %>% 
  as.data.frame()

# add new columns for the tree location coordinates 
tree_points_sf$X <- tree_coords$X
tree_points_sf$Y <- tree_coords$Y

# add empty columns for the min and max coordinates for each polygon
tree_polygons_sf$xmin <- NA 
tree_polygons_sf$xmax <- NA 
tree_polygons_sf$ymin <- NA 
tree_polygons_sf$ymax <- NA 

# add the min, max X and Y values to each polygon for filtering 
for (i in 1:nrow(tree_polygons_sf)) {
  tree_polygons_sf$xmin[i] <- as.numeric(sf::st_bbox(tree_polygons_sf$geometry[i])[1])
  tree_polygons_sf$ymin[i] <- as.numeric(sf::st_bbox(tree_polygons_sf$geometry[i])[2])
  tree_polygons_sf$xmax[i] <- as.numeric(sf::st_bbox(tree_polygons_sf$geometry[i])[3])
  tree_polygons_sf$ymax[i] <- as.numeric(sf::st_bbox(tree_polygons_sf$geometry[i])[4])
}

# merge the polygons with tree locations;
# rename the geometry columns to be more descriptive 
tree_polygons_points <- merge(as.data.frame(tree_polygons_sf),
                         as.data.frame(tree_points_sf)
                         [,c("indvdID", "X","Y","geometry")],
                         by="indvdID") %>% 
  dplyr::rename(geometry.polygon = geometry.x, 
                geometry.point = geometry.y)
```


The hyperspectral data is available in 1km x 1km square tiles.

Read the first tile metadata and reflectance data. 

```{r read_hyperspectral}
# get the names of all HDF5 files to iterate through
h5_list <- list.files(path = h5_dir, full.names = TRUE)
h5_list <- h5_list[grepl("*.h5", h5_list)]

# select first HDF5 file 
h5 <- h5_list[1]
print(h5)

# list the contents of HDF5 file
h5_struct <- rhdf5::h5ls(h5, all=T)

# construct the string using "/Reflectance/Metadata/Coordinate_System",
# without explicitly using a site code 
crs_tag <- h5_struct$group[grepl("/Reflectance/Metadata/Coordinate_System", 
                                 h5_struct$group)][1] 

# read coordinate reference system data
crs_info <- rhdf5::h5read(h5, crs_tag)

# convert "UTM" to lowercase "utm" for proper usage later
crs_info$Proj4 <- CRS(chartr("UTM", "utm", crs_info$Proj4))

# get attributes for the Reflectance dataset.
# construct the string using "/Reflectance/Reflectance_Data"" 
refl_tag <- paste0(h5_struct$group[grepl("/Reflectance", 
                                         h5_struct$group)][1],
                   "/Reflectance_Data")

# read the reflectance metadata
refl_info <- rhdf5::h5readAttributes(h5,refl_tag)

# get the dimensions of the reflectance data
n_rows <- refl_info$Dimensions[1]
n_cols <- refl_info$Dimensions[2]
n_bands <- refl_info$Dimensions[3]

# print dimensions 
print(paste0("# Rows: ", as.character(n_rows)))
print(paste0("# Columns: ", as.character(n_cols)))
print(paste0("# Bands: ", as.character(n_bands)))

# read the wavelengths of the hyperspectral image bands
wavelength_tag <- paste0(h5_struct$group[grepl("/Reflectance/Metadata/Spectral_Data", 
                                               h5_struct$group)][1],
                         "/Wavelength")
wavelengths <- rhdf5::h5read(h5,
                             wavelength_tag)

# define the "bad bands" wavelength ranges in nanometers, where atmospheric 
# absorption creates unreliable reflectance values. 
# --> Read the bad band ranges from metadata <--
bad_band_window_1 <- c(1340, 1445)
bad_band_window_2 <- c(1790, 1955)

# define spatial extent: extract resolution and origin coordinates
map_info <- unlist(strsplit(crs_info$Map_Info, 
                            split = ", "))
res_x <- as.numeric(map_info[6])
res_y <- as.numeric(map_info[7])
x_min <- as.numeric(map_info[4])
y_max <- as.numeric(map_info[5])

# calculate the maximum X and minimum Y values 
x_max <- (x_min + (n_cols * res_x))
y_min <- (y_max - (n_rows * res_y))
tile_extent <- raster::extent(x_min, x_max, y_min, y_max)

# print the extent of the current tile
print("tile extent: ")
tile_extent

# read reflectance data for all bands
refl <- rhdf5::h5read(h5, refl_tag,
                      index = list(1:n_bands, 1:n_cols, 1:n_rows))

# view and apply scale factor to convert integer values to reflectance [0,1]
# and data ignore value
scale_factor <- refl_info$Scale_Factor
data_ignore <- refl_info$Data_Ignore_Value
refl[refl == data_ignore] <- NA 
refl_scaled <- refl / scale_factor
```

Figure out which polygons are within the current tile.

```{r polygons_in_tile}
# figure out which trees are within the current tile 
polygons_in <- tree_polygons_points %>% 
  dplyr::filter(xmin > tile_extent@xmin & 
                  xmax < tile_extent@xmax & 
                  ymin > tile_extent@ymin & 
                  ymax < tile_extent@ymax)

print(paste0(as.character(nrow(polygons_in))," polygons in current tile"))

# if no polygons are within the current tile, skip to the next one
if (nrow(polygons_in)==0){
  print("no trees located within current tile")
  next
}

# convert from SF obect to SpatialPolygons object for clipping
polygons_in_sp <- sf::as_Spatial(polygons_in$geometry.polygon,
                                 IDs = as.character(polygons_in$indvdID))
points_in_sp <- sf::as_Spatial(polygons_in$geometry.point,
                                 IDs = as.character(polygons_in$indvdID))

```

Let's clip the scaled hyperspectral reflectance data to obtain reflectance curves for each tree stem point, and within each polygon area. 

```{r clip_hyperspectral_w_polygons}

# create georeferenced raster using band 1 
r1 <- (refl_scaled[1,,]) # convert first band to matrix
r1 <- raster::raster(r1, crs = crs_info$Proj4)
extent(r1) <- tile_extent

# start the raster stack with first band 
s <- raster::stack(r1)

# loop through bands and create a giant rasterstack with 426 (n_bands) bands
for(b in 2:n_bands){
  print(b)
  
  # create raster with current band
  r <- (refl_scaled[b,,]) # convert to matrix
  r <- raster::raster(r, crs = crs_info$Proj4)
  extent(r) <- tile_extent
  
  # add additional band to the stack with the addLayer function
  s <- raster::addLayer(s, r)
  
}

# adjust the names for each layer in raster stack to correspond to wavelength
names(s) <- round(wavelengths)

# clip the hyperspectral raster stack with the polygons within current tile.
# the returned objects are data frames, each row corresponds to a pixel in the
# hyperspectral imagery. The ID number refers to which polygon or point that 
# the pixel belongs to. A large polygon will lead to many extracted pixels
# (many rows in the output data frame)
extracted_polygon_spectra <- raster::extract(s, polygons_in_sp, df = TRUE)
extracted_point_spectra <- raster::extract(s, points_in_sp, df = TRUE)
```

Write the spectral reflectance data to file for each tree. 

```{r combine_write_spectra}

# combine the additional data with each spectrum for writing to file
spectra_write <- data.frame(individualID = polygons_in$indvdID,
                              scientificName = polygons_in$scntfcN,
                              taxonID = polygons_in$taxonID,
                              maxCrownDiameter = polygons_in$crownDm,
                              height = polygons_in$height,
                              X = polygons_in$X,
                              Y = polygons_in$Y,
                              as.data.frame(extracted_point_spectra))

## VS_NOTE - REMOVE ID COLUMN! 
  
write.csv(spectra_write, file = paste0(out_dir,
                                       "spectral_reflectance_",
                                        as.character(tile_extent@xmin),"_",
                                        as.character(tile_extent@ymin),".csv")) 
  
```

Plot the reflectance as a function of wavelength.

```{r plot_spectra}

# VS_NOTE - LOOP THROUGH ALL TILES AND READ ALL SPECTRA INTO SINGLE DATA FRAME
spectra_all <- spectra_write # single tile for testing

# keep just the reflectance values along with individual ID and species
# for the first tree
spectra_1 <- spectra_all[1,] %>% 
                dplyr::select(-c(X,Y,ID))

# organize the data into a data frame where the first column contains
# the individual ID, second column contains scientific name, 
# third column contains wavelength, and fourth column contains
# reflectance per wavelength.  
spectra_plot <- tidyr::gather(spectra_1,
                              key = wavelength,
                              value = "reflectance",
                              -individualID,
                              -scientificName,
                              -taxonID,
                              -maxCrownDiameter,
                              -height)
# add the actual wavelenth values into the wavelengths column
spectra_plot$wavelength <- wavelengths

# loop through the remaining spectra and repeat 
for (i in 2:nrow(spectra_all)){
  spectra_current <- spectra_all[i,] %>% 
                        dplyr::select(-c(X,Y,ID))
  spectra_current <- tidyr::gather(spectra_current,
                                key = wavelength,
                                value = "reflectance",
                                -individualID,
                                -scientificName,
                                -taxonID,
                                -maxCrownDiameter,
                                -height)
  spectra_current$wavelength <- wavelengths
  
  spectra_plot <- rbind(spectra_plot, spectra_current)
  
}

# remove the first reflectance value 
spectra_plot <- spectra_plot[spectra_plot$wavelength > 385,]

# remove the bad bands 
remove_bands <- wavelengths[(wavelengths > bad_band_window_1[1] & 
                            wavelengths < bad_band_window_1[2]) | 
                           (wavelengths > bad_band_window_2[1] & 
                            wavelengths < bad_band_window_2[2])]

spectra_plot$reflectance[spectra_plot$wavelength %in% remove_bands] <- NA
```

```{r point_spectra_single_plot, results=TRUE}
# plot all spectra on single plot 
legend_labels = c('a','b','c','d')
ggplot(data = spectra_plot, 
       aes(x = wavelength, 
           y = reflectance, 
           colour = taxonID)) +
  geom_line(aes(group = individualID)) + 
  labs(x = "wavelength (nm)", 
       color = "species") + 
  ggtitle("Hyperspectral reflectance extracted per center pixel") +
          scale_color_manual(values = c("#d7191c", "#fdae61", "#abdda4", "#2b83ba")
  )
```

```{r point_spectra_multi_plot, results=TRUE}
# Use facet_grid for a separate plot per species 
ggplot(data = spectra_plot, 
       aes(x = wavelength, 
           y = reflectance, 
           colour = taxonID)) +
  geom_line(aes(group = individualID), alpha = 0.5) + 
  facet_wrap(. ~ taxonID, ncol = 2) + 
  labs(x = "wavelength (nm)", color = "species") + 
  ggtitle("Hyperspectral reflectance extracted per center pixel") + 
  scale_color_manual(values = c("#d7191c", "#fdae61", "#abdda4", "#2b83ba"))
```

```{r}
# for each species, plot the mean reflectance curve with the variation
# shaded around it 


```

